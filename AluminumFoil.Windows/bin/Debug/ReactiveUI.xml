<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ReactiveUI</name>
    </assembly>
    <members>
        <member name="T:ReactiveUI.CanActivateViewFetcher">
            <summary>
            This class implements View Activation for classes that explicitly describe
            their activation via <see cref="T:ReactiveUI.ICanActivate"/>. This class is used by the framework.
            </summary>
        </member>
        <member name="M:ReactiveUI.CanActivateViewFetcher.GetAffinityForView(System.Type)">
            <summary>
            Returns a positive integer for derivates of the <see cref="T:ReactiveUI.ICanActivate"/> interface.
            </summary>
            <param name="view">The source type to check.</param>
            <returns>
            A positive integer if <see cref="M:ReactiveUI.CanActivateViewFetcher.GetActivationForView(ReactiveUI.IActivatable)"/> is supported,
            zero otherwise.
            </returns>
        </member>
        <member name="M:ReactiveUI.CanActivateViewFetcher.GetActivationForView(ReactiveUI.IActivatable)">
            <summary>
            Get an observable defining whether the view is active.
            </summary>
            <param name="view">The view to observe.</param>
            <returns>An observable tracking whether the view is active.</returns>
        </member>
        <member name="T:ReactiveUI.IActivationForViewFetcher">
            <summary>
            Implement this interface to override how ReactiveUI determines when a
            View is activated or deactivated. This is usually only used when porting
            ReactiveUI to a new UI framework.
            </summary>
        </member>
        <member name="M:ReactiveUI.IActivationForViewFetcher.GetAffinityForView(System.Type)">
            <summary>
            Determines the priority that the Activation View Fetcher
            will be able to process the view type.
            0 means it cannot activate the View, value larger than 0
            indicates it can activate the View.
            The class derived off IActivationForViewFetcher which returns
            the highest affinity value will be used to activate the View.
            </summary>
            <param name="view">The type for the View.</param>
            <returns>The affinity value which is equal to 0 or above.</returns>
        </member>
        <member name="M:ReactiveUI.IActivationForViewFetcher.GetActivationForView(ReactiveUI.IActivatable)">
            <summary>
            Gets a Observable which will activate the View.
            This is called after the GetAffinityForView method.
            </summary>
            <param name="view">The view to get the activation observable for.</param>
            <returns>A Observable which will returns if Activation was successful.</returns>
        </member>
        <member name="T:ReactiveUI.ViewForMixins">
            <summary>
            A set of extension methods to help wire up View and ViewModel activation.
            </summary>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.ISupportsActivation,System.Func{System.Collections.Generic.IEnumerable{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            ViewModel's View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. It returns a list of Disposables that will be
            cleaned up when the View is deactivated.
            </param>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.ISupportsActivation,System.Action{System.Action{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            ViewModel's View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'd') allows
            you to register Disposables to be cleaned up when the View is
            deactivated (i.e. "d(someObservable.Subscribe());").
            </param>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.ISupportsActivation,System.Action{System.Reactive.Disposables.CompositeDisposable})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            ViewModel's View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'disposables') allows
            you to collate all the disposables to be cleaned up during deactivation.
            </param>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Func{System.Collections.Generic.IEnumerable{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. It returns a list of Disposables that will be
            cleaned up when the View is deactivated.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Func{System.Collections.Generic.IEnumerable{System.IDisposable}},ReactiveUI.IViewFor)">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. It returns a list of Disposables that will be
            cleaned up when the View is deactivated.
            </param>
            <param name="view">
            The IActivatable will ordinarily also host the View
            Model, but in the event it is not, a class implementing <see cref="T:ReactiveUI.IViewFor" />
            can be supplied here.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Action{System.Action{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'd') allows
            you to register Disposables to be cleaned up when the View is
            deactivated (i.e. "d(someObservable.Subscribe());").
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Action{System.Action{System.IDisposable}},ReactiveUI.IViewFor)">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'd') allows
            you to register Disposables to be cleaned up when the View is
            deactivated (i.e. "d(someObservable.Subscribe());").
            </param>
            <param name="view">
            The IActivatable will ordinarily also host the View
            Model, but in the event it is not, a class implementing <see cref="T:ReactiveUI.IViewFor" />
            can be supplied here.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Action{System.Reactive.Disposables.CompositeDisposable},ReactiveUI.IViewFor)">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="this">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'disposables') allows
            you to collate all disposables that should be cleaned up during deactivation.
            </param>
            <param name="view">
            The IActivatable will ordinarily also host the View
            Model, but in the event it is not, a class implementing <see cref="T:ReactiveUI.IViewFor" />
            can be supplied here.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="T:ReactiveUI.ViewModelActivator">
             <summary>
             ViewModelActivator is a helper class that you instantiate in your
             ViewModel classes in order to help with Activation. Views will internally
             call this class when the corresponding View comes on screen. This means
             you can set up resources such as subscriptions to global objects that
             should be cleaned up on exit. Once you instantiate this class, use the
             WhenActivated method to register what to do when activated.
            
             View Activation is  **not** the same as being loaded / unloaded; Views
             are Activated when they *enter* the Visual Tree, and are Deactivated when
             they *leave* the Visual Tree. This is a critical difference when it comes
             to views that are recycled, such as UITableViews or Virtualizing
             ScrollViews.
            
             Create this class solely in the **Base Class** of any classes that inherit
             from this class (i.e. if you create a FooViewModel that supports activation,
             the instance should be protected and a child BarViewModel should use the
             existing ViewModelActivator).
            
             NOTE: You **must** set up Activation in the corresponding View when using
             ViewModel Activation.
             </summary>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ViewModelActivator"/> class.
            </summary>
        </member>
        <member name="P:ReactiveUI.ViewModelActivator.Activated">
            <summary>
            Gets a observable which will tick every time the Activator is activated.
            </summary>
            <value>The activated.</value>
        </member>
        <member name="P:ReactiveUI.ViewModelActivator.Deactivated">
            <summary>
            Gets a observable observable which will tick every time the Activator is deactivated.
            </summary>
            <value>The deactivated.</value>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.Activate">
            <summary>
            This method is called by the framework when the corresponding View
            is activated. Call this method in unit tests to simulate a ViewModel
            being activated.
            </summary>
            <returns>A Disposable that calls Deactivate when disposed.</returns>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.Deactivate(System.Boolean)">
            <summary>
            This method is called by the framework when the corresponding View
            is deactivated.
            </summary>
            <param name="ignoreRefCount">
            Force the VM to be deactivated, even
            if more than one person called Activate.
            </param>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.AddActivationBlock(System.Func{System.Collections.Generic.IEnumerable{System.IDisposable}})">
            <summary>
            Adds a action blocks to the list of registered blocks. These will called
            on activation, then disposed on deactivation.
            </summary>
            <param name="block">The block to add.</param>
        </member>
        <member name="T:ReactiveUI.CommandBinder">
            <summary>
            Various helpers to bind View controls and ViewModel commands together.
            </summary>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.IObservable{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <typeparam name="TView">The view type.</typeparam>
            <typeparam name="TViewModel">The view model type.</typeparam>
            <typeparam name="TProp">The property type.</typeparam>
            <typeparam name="TControl">The control type.</typeparam>
            <typeparam name="TParam">The parameter type.</typeparam>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding.</returns>
            <param name="view">The View.</param>
            <param name="viewModel">The View model.</param>
            <param name="propertyName">The ViewModel command to bind.</param>
            <param name="controlName">The name of the control on the view.</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand.</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.
            NOTE: If this parameter is used inside WhenActivated, it's
            important to dispose the binding when the view is deactivated.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <typeparam name="TView">The view type.</typeparam>
            <typeparam name="TViewModel">The view model type.</typeparam>
            <typeparam name="TProp">The property type.</typeparam>
            <typeparam name="TControl">The control type.</typeparam>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding.</returns>
            <param name="view">The View.</param>
            <param name="viewModel">The View model.</param>
            <param name="propertyName">The ViewModel command to bind.</param>
            <param name="controlName">The name of the control on the view.</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.
            NOTE: If this parameter is used inside WhenActivated, it's
            important to dispose the binding when the view is deactivated.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``1,``4}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <typeparam name="TView">The view type.</typeparam>
            <typeparam name="TViewModel">The view model type.</typeparam>
            <typeparam name="TProp">The property type.</typeparam>
            <typeparam name="TControl">The control type.</typeparam>
            <typeparam name="TParam">The parameter type.</typeparam>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding.</returns>
            <param name="view">The View.</param>
            <param name="viewModel">The View model.</param>
            <param name="propertyName">The ViewModel command to bind.</param>
            <param name="controlName">The name of the control on the view.</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand.</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.
            NOTE: If this parameter is used inside WhenActivated, it's
            important to dispose the binding when the view is deactivated.</param>
        </member>
        <member name="T:ReactiveUI.CommandBinderImplementation">
            <summary>
            Used by the CommandBinder extension methods to handle binding View controls and ViewModel commands.
            </summary>
        </member>
        <member name="M:ReactiveUI.CommandBinderImplementation.BindCommand``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <typeparam name="TView">The view type.</typeparam>
            <typeparam name="TViewModel">The view model type.</typeparam>
            <typeparam name="TProp">The property type.</typeparam>
            <typeparam name="TControl">The control type.</typeparam>
            <typeparam name="TParam">The parameter type.</typeparam>
            <param name="viewModel">The View model.</param>
            <param name="view">The View.</param>
            <param name="vmProperty">The ViewModel command to bind.</param>
            <param name="controlProperty">The name of the control on the view.</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand.</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.
            NOTE: If this parameter is used inside WhenActivated, it's
            important to dispose the binding when the view is deactivated.</param>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding.</returns>
        </member>
        <member name="M:ReactiveUI.CommandBinderImplementation.BindCommand``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.IObservable{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <typeparam name="TView">The view type.</typeparam>
            <typeparam name="TViewModel">The view model type.</typeparam>
            <typeparam name="TProp">The property type.</typeparam>
            <typeparam name="TControl">The control type.</typeparam>
            <typeparam name="TParam">The parameter type.</typeparam>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding.</returns>
            <param name="viewModel">The View model.</param>
            <param name="view">The View.</param>
            <param name="vmProperty">The ViewModel command to bind.</param>
            <param name="controlProperty">The name of the control on the view.</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand.</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.
            NOTE: If this parameter is used inside WhenActivated, it's
            important to dispose the binding when the view is deactivated.</param>
        </member>
        <member name="T:ReactiveUI.CommandBinderImplementationMixins">
            <summary>
            Internal implementation details which performs Binding ICommand's to controls.
            </summary>
        </member>
        <member name="T:ReactiveUI.CreatesCommandBindingViaCommandParameter">
            <summary>
            Class that registers Command Binding and Command Parameter Binding.
            </summary>
        </member>
        <member name="M:ReactiveUI.CreatesCommandBindingViaCommandParameter.GetAffinityForObject(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CreatesCommandBindingViaCommandParameter.BindCommandToObject(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CreatesCommandBindingViaCommandParameter.BindCommandToObject``1(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object},System.String)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.CreatesCommandBindingViaEvent">
            <summary>
            This binder is the default binder for connecting to arbitrary events.
            </summary>
        </member>
        <member name="M:ReactiveUI.CreatesCommandBindingViaEvent.GetAffinityForObject(System.Type,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CreatesCommandBindingViaEvent.BindCommandToObject(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CreatesCommandBindingViaEvent.BindCommandToObject``1(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object},System.String)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.ICommandBinderImplementation">
            <summary>
            Implementation logic for command binding.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICommandBinderImplementation.BindCommand``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``4},System.String)">
            <summary>
            Binds the command on a ViewModel to a control on the View.
            </summary>
            <param name="viewModel">The view model to bind to.</param>
            <param name="view">The view to bind to.</param>
            <param name="propertyName">The name of the property on the View Model.</param>
            <param name="controlName">The name of the control on the View.</param>
            <param name="withParameter">A function if we want to pass a parameter to the ICommand.</param>
            <param name="toEvent">A event on the view that will also trigger the command.</param>
            <typeparam name="TView">The type of the view.</typeparam>
            <typeparam name="TViewModel">The type of the view model.</typeparam>
            <typeparam name="TProp">The type of the property on the view model.</typeparam>
            <typeparam name="TControl">The type of control on the view.</typeparam>
            <typeparam name="TParam">The type of the parameter to pass to the ICommand.</typeparam>
            <returns>A reactive binding. Often only used for disposing the binding.</returns>
        </member>
        <member name="M:ReactiveUI.ICommandBinderImplementation.BindCommand``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.IObservable{``4},System.String)">
            <summary>
            Binds the command on a ViewModel to a control on the View.
            </summary>
            <param name="viewModel">The view model to bind to.</param>
            <param name="view">The view to bind to.</param>
            <param name="propertyName">The name of the property on the View Model.</param>
            <param name="controlName">The name of the control on the View.</param>
            <param name="withParameter">A observable if we want to pass a parameter to the ICommand.</param>
            <param name="toEvent">A event on the view that will also trigger the command.</param>
            <typeparam name="TView">The type of the view.</typeparam>
            <typeparam name="TViewModel">The type of the view model.</typeparam>
            <typeparam name="TProp">The type of the property on the view model.</typeparam>
            <typeparam name="TControl">The type of control on the view.</typeparam>
            <typeparam name="TParam">The type of the parameter to pass to the ICommand.</typeparam>
            <returns>A reactive binding. Often only used for disposing the binding.</returns>
        </member>
        <member name="T:ReactiveUI.RelayCommand">
            <summary>
            Internal relay command used for Command binding.
            </summary>
        </member>
        <member name="T:ReactiveUI.EqualityTypeConverter">
            <summary>
            The default converter, simply converts between types that are equal or
            can be converted (i.e. Button => UIControl).
            </summary>
        </member>
        <member name="M:ReactiveUI.EqualityTypeConverter.DoReferenceCast(System.Object,System.Type)">
            <summary>
            Handles casting for a reference. Understands about nullable types
            and can cast appropriately.
            </summary>
            <param name="from">The object we are casting from.</param>
            <param name="targetType">The target we want to cast to.</param>
            <returns>The new value after it has been casted.</returns>
            <exception cref="T:System.InvalidCastException">If we cannot cast the object.</exception>
        </member>
        <member name="M:ReactiveUI.EqualityTypeConverter.GetAffinityForObjects(System.Type,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.EqualityTypeConverter.TryConvert(System.Object,System.Type,System.Object,System.Object@)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.StringConverter">
            <summary>
            Calls ToString on types. In WPF, ComponentTypeConverter should win
            instead of this, since It's Betterâ„¢.
            </summary>
        </member>
        <member name="M:ReactiveUI.StringConverter.GetAffinityForObjects(System.Type,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.StringConverter.TryConvert(System.Object,System.Type,System.Object,System.Object@)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.IPropertyBinderImplementation">
            <summary>
            This interface represents an object that is capable
            of providing binding implementations.
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/>
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            viewModel to view property.
            </param>
            <param name="viewToVMConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            view to viewModel property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/>
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a one-way binding, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only. This binding will
            attempt to convert the value of the view model property to the view property if they
            are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            viewModel to view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
            <exception cref="T:System.ArgumentException">
            There is no registered converter from <typeparamref name="TVMProp"/> to <typeparamref name="TVProp"/>.
            </exception>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3})">
            <summary>
            Creates a one way binding with a selector, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only, and where the value of the view model
            property is mapped through the <paramref name="selector"/> before being set to the view.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to <c>Subscribe(x =&gt;
            target.property = x)</c>, but allows you to use child properties
            without the null checks.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <typeparam name="TTValue">The target value type.</typeparam>
            <param name="observedChange">The target observable to bind to.</param>
            <param name="target">The target object whose property will be set.</param>
            <param name="propertyExpression">
            An expression representing the target property to set.
            This can be a child property (i.e. <c>x.Foo.Bar.Baz</c>).
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            viewModel to view property.
            </param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.PropertyBinderImplementation">
            <summary>
            Provides methods to bind properties to observables.
            </summary>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
             <summary>
             Creates a two-way binding between a view model and a view.
             This binding will attempt to convert the values of the
             view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
             if they are not of the same type.
             </summary>
             <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
             <typeparam name="TView">The type of the view being bound.</typeparam>
             <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
             <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
             <typeparam name="TDontCare">
             A dummy type, only the fact that <paramref name="signalViewUpdate"/>
             emits values is considered, not the actual values emitted.
             </typeparam>
             <param name="viewModel">The instance of the view model object to be bound.</param>
             <param name="view">The instance of the view object to be bound.</param>
             <param name="vmProperty">
             An expression representing the property to be bound to on the view model.
             This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
             the binding will attempt to subscribe recursively to updates in order to
             always get and set the correct property.
             </param>
             <param name="viewProperty">
             An expression representing the property to be bound to on the view.
             This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
             the binding will attempt to subscribe recursively to updates in order to
             always get and set the correct property.
            
             If it is left null, the framework will attempt to automagically figure out
             the control and property that is to be bound, by looking for a control of the
             same name as the <paramref name="vmProperty"/>, and its most natural property.
             </param>
             <param name="signalViewUpdate">
             An observable, that when signaled, indicates that the view property
             has been changed, and that the binding should update the view model
             property accordingly.
             </param>
             <param name="conversionHint">
             An object that can provide a hint for the converter.
             The semantics of this object is defined by the converter used.
             </param>
             <param name="vmToViewConverterOverride">
             An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
             viewModel to view property.
             </param>
             <param name="viewToVMConverterOverride">
             An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
             view to viewModel property.
             </param>
             <returns>
             An instance of <see cref="T:System.IDisposable"/> that, when disposed,
             disconnects the binding.
             </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/>
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="view">The instance of the view to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <c>vm =&gt; vm.Foo.Bar.Baz</c>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form. <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter)">
             <summary>
             Creates a one-way binding, i.e. a binding that flows from the
             <paramref name="viewModel"/> to the <paramref name="view"/> only. This binding will
             attempt to convert the value of the view model property to the view property if they
             are not of the same type.
             </summary>
             <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
             <typeparam name="TView">The type of the view that is bound.</typeparam>
             <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
             <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
             <param name="viewModel">The instance of the view model to bind to.</param>
             <param name="view">The instance of the view to bind to.</param>
             <param name="vmProperty">
             An expression representing the property to be bound to on the view model.
             This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
             the binding will attempt to subscribe recursively to updates in order to
             always get the last value of the property chain.
             </param>
             <param name="viewProperty">
             An expression representing the property to be bound to on the view.
             This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
             the binding will attempt to subscribe recursively to updates in order to
             always set the correct property.
            
             If it is left null, the framework will attempt to automagically figure out
             the control and property that is to be bound, by looking for a control of the
             same name as the <paramref name="vmProperty"/>, and its most natural property.
             </param>
             <param name="conversionHint">
             An object that can provide a hint for the converter.
             The semantics of this object is defined by the converter used.
             </param>
             <param name="vmToViewConverterOverride">
             Delegate to convert the value of the view model's property's type to a value of the
             view's property's type.
             </param>
             <returns>
             An instance of <see cref="T:System.IDisposable"/> that, when disposed,
             disconnects the binding.
             </returns>
             <exception cref="T:System.ArgumentException">
             There is no registered converter from <typeparamref name="TVMProp"/> to <typeparamref name="TVProp"/>.
             </exception>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3})">
             <summary>
             Creates a one way binding with a selector, i.e. a binding that flows from the
             <paramref name="viewModel"/> to the <paramref name="view"/> only, and where the value of the view model
             property is mapped through the <paramref name="selector"/> before being set to the view.
             </summary>
             <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
             <typeparam name="TView">The type of the view that is bound.</typeparam>
             <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
             <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
             <param name="viewModel">The instance of the view model to bind to.</param>
             <param name="view">The instance of the view to bind to.</param>
             <param name="vmProperty">
             An expression representing the property to be bound to on the view model.
             This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
             the binding will attempt to subscribe recursively to updates in order to
             always get the last value of the property chain.
             </param>
             <param name="viewProperty">
             An expression representing the property to be bound to on the view.
             This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
             the binding will attempt to subscribe recursively to updates in order to
             always set the correct property.
            
             If it is left null, the framework will attempt to automagically figure out
             the control and property that is to be bound, by looking for a control of the
             same name as the <paramref name="vmProperty"/>, and its most natural property.
             </param>
             <param name="selector">
             A function that will be used to transform the values of the property on the view model
             before being bound to the view property.
             </param>
             <returns>
             An instance of <see cref="T:System.IDisposable"/> that, when disposed,
             disconnects the binding.
             </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to <c>Subscribe(x =&gt;
            target.property = x)</c>, but allows you to use child properties
            without the null checks.
            </summary>
            <typeparam name="TValue">The source type.</typeparam>
            <typeparam name="TTarget">The target object type.</typeparam>
            <typeparam name="TTValue">The type of the property on the target object.</typeparam>
            <param name="observedChange">The observable to apply to the target property.</param>
            <param name="target">The target object whose property will be set.</param>
            <param name="propertyExpression">
            An expression representing the target property to set.
            This can be a child property (i.e. <c>x.Foo.Bar.Baz</c>).</param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.PropertyBindingMixins">
            <summary>
            This class provides extension methods for the ReactiveUI view binding mechanism.
            </summary>
        </member>
        <member name="M:ReactiveUI.PropertyBindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form. <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form. <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            viewModel to view property.
            </param>
            <param name="viewToVMConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            view to viewModel property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBindingMixins.Bind``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property, and
            provide a custom view update signaller to signal when the view property has been updated.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/>
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form. <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form. <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            viewModel to view property.
            </param>
            <param name="viewToVMConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            view to viewModel property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form. <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form. <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBindingMixins.Bind``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            /// <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/>
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form. <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form. <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the given property on the view model to a given property on the view in a one-way (view model to view) fashion.
            </summary>
            <typeparam name="TViewModel">The type of the view model.</typeparam>
            <typeparam name="TView">The type of the view.</typeparam>
            <typeparam name="TVMProp">The type of view model property.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">
            The instance of the view object which is bound. Usually, it is the. <code>this</code>
            instance.
            </param>
            <param name="viewModel">
            The view model that is bound.
            It is usually set to the <see cref="P:ReactiveUI.IViewFor.ViewModel"/> property of the <paramref name="view"/>.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form. <code>vm => vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form. <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            viewModel to view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3})">
            <summary>
            Binds the specified view model property to the given view, in a one-way (view model to view) fashion,
            with the value of the view model property mapped through a <paramref name="selector"/> function.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="view">The instance of the view to bind to.</param>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBindingMixins.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to <c>Subscribe(x =&gt;
            target.property = x)</c>, but allows you to use child properties
            without the null checks.
            </summary>
            <typeparam name="TValue">The source type.</typeparam>
            <typeparam name="TTarget">The target object type.</typeparam>
            <typeparam name="TTValue">The type of the property on the target object.</typeparam>
            <param name="this">The observable stream to bind to a target property.</param>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">
            An expression representing the target property to set.
            This can be a child property (i.e. <c>x.Foo.Bar.Baz</c>).
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the
            viewModel to view property.
            </param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.IReactiveBinding`3">
            <summary>
            This interface represents the result of a Bind/OneWayBind and gives
            information about the binding. When this object is disposed, it will
            destroy the binding it is describing (i.e. most of the time you won't
            actually care about this object, just that it is disposable).
            </summary>
            <typeparam name="TView">The view type.</typeparam>
            <typeparam name="TViewModel">The view model type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewModel">
            <summary>
            Gets the instance of the view model this binding is applied to.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewModelExpression">
            <summary>
            Gets an expression representing the propertyon the viewmodel bound to the view.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.View">
            <summary>
            Gets the instance of the view this binding is applied to.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewExpression">
            <summary>
            Gets an expression representing the property on the view bound to the viewmodel.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.Changed">
            <summary>
            Gets an observable representing changed values for the binding.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.Direction">
            <summary>
            Gets the direction of the binding.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewModel">
            <inheritdoc />
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewModelExpression">
            <inheritdoc />
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.View">
            <inheritdoc />
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewExpression">
            <inheritdoc />
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.Changed">
            <inheritdoc />
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.Direction">
            <inheritdoc />
        </member>
        <member name="M:ReactiveUI.ReactiveBinding`3.Dispose">
            <inheritdoc />
        </member>
        <member name="M:ReactiveUI.ReactiveBinding`3.Dispose(System.Boolean)">
            <summary>
            Disposes of resources inside the class.
            </summary>
            <param name="isDisposing">If we are disposing managed resources.</param>
        </member>
        <member name="M:ReactiveUI.ChainedComparer`1.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:ReactiveUI.ComparerChainingExtensions">
            <summary>
            Convenience class to help chain selectors onto existing parent comparers.
            </summary>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <typeparam name="T">The comparison type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <typeparam name="T">The comparison type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <typeparam name="T">The comparison type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <typeparam name="T">The comparison type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="T:ReactiveUI.IComparerBuilder`1">
            <summary>
            Convienience interface for providing a starting point for chaining comparers.
            </summary>
            <typeparam name="T">The comparison type.</typeparam>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            The default comparer for that type will be used if this parameter is null.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            /// <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            The default comparer for that type will be used if this parameter is null.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="T:ReactiveUI.OrderedComparer">
            <summary>
            Convenience class providing a starting point for chaining comparers for anonymous types.
            </summary>
            <remarks>
            If the type you're creating a comparer for is known this class is nothing more than an alias for the generic
            OrderedComparer. This class can be used to create comparers for anonymous types.
            </remarks>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a type inferred comparer builder for the element type of the enumerable. Useful for creating
            comparers for anonymous types. Note that the builder is not a comparer in itself, you need to use the
            OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <param name="enumerable">The enumerable.</param>
            <returns>A comparer builder.</returns>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1">
            <summary>
            Creates a comparer builder for the specified type. Note that the builder is not a comparer in itself,
            you need to use the OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            If the type is known at compile time this method is nothing more than an alias for the generic
            OrdedComparer class.
            </summary>
            <typeparam name="T">The comparison type.</typeparam>
            <returns>A comparer builder.</returns>
        </member>
        <member name="T:ReactiveUI.OrderedComparer`1">
            <summary>
            Convenience class providing a starting point for chaining comparers.
            </summary>
            <typeparam name="T">The comparison type.</typeparam>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the
            return type of the selector if no comparer is specified.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            The default comparer for that type will be used if this parameter is null.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the
            return type of the selector if no comparer is specified.
            </summary>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector.
            The default comparer for that type will be used if this parameter is null.
            </param>
            <returns>A comparer.</returns>
        </member>
        <member name="T:ReactiveUI.INotifyPropertyChanging">
            <summary>
            Classes which implement this interface will notify
            external users when a property is changing.
            </summary>
        </member>
        <member name="E:ReactiveUI.INotifyPropertyChanging.PropertyChanging">
            <summary>
            An event that is triggered before a property's value is going to change.
            </summary>
        </member>
        <member name="T:ReactiveUI.PropertyChangingEventArgs">
            <summary>
            The arguments for the PropertyChanging event.
            </summary>
        </member>
        <member name="M:ReactiveUI.PropertyChangingEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.PropertyChangingEventArgs"/> class.
            </summary>
            <param name="propertyName">The name of the property that is changing.</param>
        </member>
        <member name="P:ReactiveUI.PropertyChangingEventArgs.PropertyName">
            <summary>
            Gets or sets the name of the property that is changing.
            </summary>
        </member>
        <member name="T:ReactiveUI.PropertyChangingEventHandler">
            <summary>
            Event handler for the property changing events.
            This will be called before a property value has changed.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="e">Details about the changing property.</param>
        </member>
        <member name="T:ReactiveUI.WeakEventManager`3">
            <summary>
            WeakEventManager base class. Inspired by the WPF WeakEventManager class and the code in
            http://social.msdn.microsoft.com/Forums/silverlight/en-US/34d85c3f-52ea-4adc-bb32-8297f5549042/command-binding-memory-leak?forum=silverlightbugs.
            </summary>
            <typeparam name="TEventSource">The type of the event source.</typeparam>
            <typeparam name="TEventHandler">The type of the event handler.</typeparam>
            <typeparam name="TEventArgs">The type of the event arguments.</typeparam>
        </member>
        <member name="F:ReactiveUI.WeakEventManager`3._targetToEventHandler">
            <summary>
            Mapping between the target of the delegate (for example a Button) and the handler (EventHandler).
            Windows Phone needs this, otherwise the event handler gets garbage collected.
            </summary>
        </member>
        <member name="F:ReactiveUI.WeakEventManager`3._sourceToWeakHandlers">
            <summary>
            Mapping from the source of the event to the list of handlers. This is a CWT to ensure it does not leak the source of the event.
            </summary>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.WeakEventManager`3"/> class.
            Protected to disallow instances of this class and force a subclass.
            </summary>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.AddHandler(`0,`1)">
            <summary>
            Adds a weak reference to the handler and associates it with the source.
            </summary>
            <param name="source">The source.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.RemoveHandler(`0,`1)">
            <summary>
            Removes the association between the source and the handler.
            </summary>
            <param name="source">The source.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.DeliverEvent(`0,`2)">
            <summary>
            Delivers the event to the handlers registered for the source.
            </summary>
            <param name="sender">The sender.</param>
            <param name="args">The arguments instance containing the event data.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.StartListening(System.Object)">
            <summary>
            Override this method to attach to an event.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.StopListening(System.Object)">
            <summary>
            Override this method to detach from an event.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="T:ReactiveUI.ExpressionRewriter">
            <summary>
            Class for simplifying and validating expressions.
            </summary>
        </member>
        <member name="T:ReactiveUI.Reflection">
            <summary>
            Helper class for handling Reflection amd Expression tree related items.
            </summary>
        </member>
        <member name="M:ReactiveUI.Reflection.Rewrite(System.Linq.Expressions.Expression)">
            <summary>
            Uses the expression re-writer to simplify the Expression down to it's simplest Expression.
            </summary>
            <param name="expression">The expression to rewrite.</param>
            <returns>The rewritten expression.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.ExpressionToPropertyNames(System.Linq.Expressions.Expression)">
            <summary>
            Will convert a Expression which points towards a property
            to a string containing the property names.
            The sub-properties will be separated by the '.' character.
            Index based values will include [] after the name.
            </summary>
            <param name="expression">The expression to generate the property names from.</param>
            <returns>A string form for the property the expression is pointing to.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.GetValueFetcherForProperty(System.Reflection.MemberInfo)">
            <summary>
            Converts a MemberInfo into a Func which will fetch the value for the Member.
            Handles either fields or properties.
            </summary>
            <param name="member">The member info to convert.</param>
            <returns>A Func that takes in the object/indexes and returns the value.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.GetValueFetcherOrThrow(System.Reflection.MemberInfo)">
            <summary>
            Converts a MemberInfo into a Func which will fetch the value for the Member.
            Handles either fields or properties.
            If there is no field or property with the matching MemberInfo it'll throw
            an ArgumentException.
            </summary>
            <param name="member">The member info to convert.</param>
            <returns>A Func that takes in the object/indexes and returns the value.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.GetValueSetterForProperty(System.Reflection.MemberInfo)">
            <summary>
            Converts a MemberInfo into a Func which will set the value for the Member.
            Handles either fields or properties.
            If there is no field or property with the matching MemberInfo it'll throw
            an ArgumentException.
            </summary>
            <param name="member">The member info to convert.</param>
            <returns>A Func that takes in the object/indexes and sets the value.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.GetValueSetterOrThrow(System.Reflection.MemberInfo)">
            <summary>
            Converts a MemberInfo into a Func which will set the value for the Member.
            Handles either fields or properties.
            If there is no field or property with the matching MemberInfo it'll throw
            an ArgumentException.
            </summary>
            <param name="member">The member info to convert.</param>
            <returns>A Func that takes in the object/indexes and sets the value.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.TryGetValueForPropertyChain``1(``0@,System.Object,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
            <summary>
            Based on a list of Expressions get the value of the last property in the chain if possible.
            The Expressions are typically property chains. Eg Property1.Property2.Property3
            The method will make sure that each Expression can get a value along the way
            and get each property until each expression is evaluated.
            </summary>
            <param name="changeValue">A output value where to store the value if the value can be fetched.</param>
            <param name="current">The object that starts the property chain.</param>
            <param name="expressionChain">A list of expressions which will point towards a property or field.</param>
            <typeparam name="TValue">The type of the end value we are trying to get.</typeparam>
            <returns>If the value was successfully retrieved or not.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.TryGetAllValuesForPropertyChain(ReactiveUI.IObservedChange{System.Object,System.Object}[]@,System.Object,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
            <summary>
            Based on a list of Expressions get a IObservedChanged for the value
            of the last property in the chain if possible.
            The Expressions are property chains. Eg Property1.Property2.Property3
            The method will make sure that each Expression can get a value along the way
            and get each property until each expression is evaluated.
            </summary>
            <param name="changeValues">A IObservedChanged for the value.</param>
            <param name="current">The object that starts the property chain.</param>
            <param name="expressionChain">A list of expressions which will point towards a property or field.</param>
            <returns>If the value was successfully retrieved or not.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.TrySetValueToPropertyChain``1(System.Object,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},``0,System.Boolean)">
            <summary>
            Based on a list of Expressions set a value
            of the last property in the chain if possible.
            The Expressions are property chains. Eg Property1.Property2.Property3
            The method will make sure that each Expression can use each value along the way
            and set the last value.
            </summary>
            <param name="target">The object that starts the property chain.</param>
            <param name="expressionChain">A list of expressions which will point towards a property or field.</param>
            <param name="value">The value to set on the last property in the Expression chain.</param>
            <param name="shouldThrow">If we should throw if we are unable to set the value.</param>
            <typeparam name="TValue">The type of the end value we are trying to set.</typeparam>
            <returns>If the value was successfully retrieved or not.</returns>
        </member>
        <member name="M:ReactiveUI.Reflection.ReallyFindType(System.String,System.Boolean)">
            <summary>
            Gets a Type from the specified type name.
            Uses a cache to avoid having to use Reflection every time.
            </summary>
            <param name="type">The name of the type.</param>
            <param name="throwOnFailure">If we should throw an exception if the type can't be found.</param>
            <returns>The type that was found or null.</returns>
            <exception cref="T:System.TypeLoadException">If we were unable to find the type.</exception>
        </member>
        <member name="M:ReactiveUI.Reflection.GetEventArgsTypeForEvent(System.Type,System.String)">
            <summary>
            Gets the appropriate EventArgs derived object for the specified event name for a Type.
            </summary>
            <param name="type">The type of object to find the event on.</param>
            <param name="eventName">The mame of the event.</param>
            <returns>The Type of the EventArgs to use.</returns>
            <exception cref="T:System.Exception">If there is no event matching the name on the target type.</exception>
        </member>
        <member name="M:ReactiveUI.Reflection.ThrowIfMethodsNotOverloaded(System.String,System.Object,System.String[])">
            <summary>
            Checks to make sure that the specified method names on the target object
            are overriden.
            </summary>
            <param name="callingTypeName">The name of the calling type.</param>
            <param name="targetObject">The object to check.</param>
            <param name="methodsToCheck">The name of the methods to check.</param>
            <exception cref="T:System.Exception">Thrown if the methods aren't overriden on the target object.</exception>
        </member>
        <member name="M:ReactiveUI.Reflection.IsStatic(System.Reflection.PropertyInfo)">
            <summary>
            Determines if the specified property is static or not.
            </summary>
            <param name="this">The property information to check.</param>
            <returns>If the property is static or not.</returns>
        </member>
        <member name="T:ReactiveUI.Interaction`2">
            <summary>
            Represents an interaction between collaborating parties.
            </summary>
            <remarks>
            <para>
            Interactions allow collaborating components to asynchronously ask questions of each other. Typically,
            a view model wants to ask the user a question before proceeding with some operation, and it's the view
            that provides the interface via which users can answer the question.
            </para>
            <para>
            Interactions have both an input and output, both of which are strongly-typed via generic type parameters.
            The input is passed into the interaction so that handlers have the information they require. The output
            is provided by a handler.
            </para>
            <para>
            By default, handlers are invoked in reverse order of registration. That is, handlers registered later
            are given the opportunity to handle interactions before handlers that were registered earlier. This
            chaining mechanism enables handlers to be registered temporarily in a specific context, such that
            interactions can be handled in a different manner. Subclasses may modify this behavior by overriding
            the <see cref="M:ReactiveUI.Interaction`2.Handle(`0)"/> method.
            </para>
            <para>
            Note that handlers are not required to handle an interaction. They can choose to ignore it, leaving it
            for some other handler to handle. If no handler handles the interaction, the <see cref="M:ReactiveUI.Interaction`2.Handle(`0)"/> method
            will throw an <see cref="T:ReactiveUI.UnhandledInteractionException`2"/>.
            </para>
            </remarks>
            <typeparam name="TInput">
            The interaction's input type.
            </typeparam>
            <typeparam name="TOutput">
            The interaction's output type.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.Interaction`2.#ctor(System.Reactive.Concurrency.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.Interaction`2"/> class.
            </summary>
            <param name="handlerScheduler">
            The scheduler to use when invoking handlers, which defaults to <c>CurrentThreadScheduler.Instance</c> if <see langword="null"/>.
            </param>
        </member>
        <member name="M:ReactiveUI.Interaction`2.RegisterHandler(System.Action{ReactiveUI.InteractionContext{`0,`1}})">
            <summary>
            Registers a synchronous interaction handler.
            </summary>
            <remarks>
            <para>
            This overload of <c>RegisterHandler</c> is only useful if the handler can handle the interaction
            immediately. That is, it does not need to wait for a user or some other collaborating component.
            </para>
            </remarks>
            <param name="handler">
            The handler.
            </param>
            <returns>
            A disposable which, when disposed, will unregister the handler.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.RegisterHandler(System.Func{ReactiveUI.InteractionContext{`0,`1},System.Threading.Tasks.Task})">
            <summary>
            Registers a task-based asynchronous interaction handler.
            </summary>
            <remarks>
            <para>
            This overload of <c>RegisterHandler</c> is useful if the handler needs to perform some asynchronous
            operation, such as displaying a dialog and waiting for the user's response.
            </para>
            </remarks>
            <param name="handler">
            The handler.
            </param>
            <returns>
            A disposable which, when disposed, will unregister the handler.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.RegisterHandler``1(System.Func{ReactiveUI.InteractionContext{`0,`1},System.IObservable{``0}})">
            <summary>
            Registers an observable-based asynchronous interaction handler.
            </summary>
            <typeparam name="TDontCare">The signal type.</typeparam>
            <remarks>
            <para>
            This overload of <c>RegisterHandler</c> is useful if the handler needs to perform some asynchronous
            operation, such as displaying a dialog and waiting for the user's response.
            </para>
            </remarks>
            <param name="handler">
            The handler.
            </param>
            <returns>
            A disposable which, when disposed, will unregister the handler.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.Handle(`0)">
            <summary>
            Handles an interaction and asynchronously returns the result.
            </summary>
            <remarks>
            <para>
            This method passes the interaction through to relevant handlers in reverse order of registration,
            ceasing once any handler handles the interaction. If the interaction remains unhandled after all
            relevant handlers have executed, an <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> is thrown.
            </para>
            </remarks>
            <param name="input">
            The input for the interaction.
            </param>
            <returns>
            An observable that ticks when the interaction completes, or throws an
            <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> if no handler handles the interaction.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.GetHandlers">
            <summary>
            Gets all registered handlers in order of their registration.
            </summary>
            <returns>
            All registered handlers.
            </returns>
        </member>
        <member name="T:ReactiveUI.InteractionContext`2">
            <summary>
            Contains contextual information for an interaction.
            </summary>
            <remarks>
            <para>
            Instances of this class are passed into interaction handlers. The <see cref="P:ReactiveUI.InteractionContext`2.Input"/> property exposes
            the input to the interaction, whilst the <see cref="M:ReactiveUI.InteractionContext`2.SetOutput(`1)"/> method allows a handler to provide the
            output.
            </para>
            </remarks>
            <typeparam name="TInput">
            The type of the interaction's input.
            </typeparam>
            <typeparam name="TOutput">
            The type of the interaction's output.
            </typeparam>
        </member>
        <member name="P:ReactiveUI.InteractionContext`2.Input">
            <summary>
            Gets the input for the interaction.
            </summary>
        </member>
        <member name="P:ReactiveUI.InteractionContext`2.IsHandled">
            <summary>
            Gets a value indicating whether the interaction is handled. That is, whether the output has been set.
            </summary>
        </member>
        <member name="M:ReactiveUI.InteractionContext`2.SetOutput(`1)">
            <summary>
            Sets the output for the interaction.
            </summary>
            <param name="output">
            The output.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If the output has already been set.
            </exception>
        </member>
        <member name="M:ReactiveUI.InteractionContext`2.GetOutput">
            <summary>
            Gets the output of the interaction.
            </summary>
            <returns>
            The output.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If the output has not been set.
            </exception>
        </member>
        <member name="T:ReactiveUI.UnhandledInteractionException`2">
            <summary>
            Indicates that an interaction has gone unhandled.
            </summary>
            <typeparam name="TInput">
            The type of the interaction's input.
            </typeparam>
            <typeparam name="TOutput">
            The type of the interaction's output.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.UnhandledInteractionException`2.#ctor(ReactiveUI.Interaction{`0,`1},`0)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> class.
            </summary>
            <param name="interaction">The interaction that doesn't have a input handler.</param>
            <param name="input">The input into the interaction.</param>
        </member>
        <member name="M:ReactiveUI.UnhandledInteractionException`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> class.
            </summary>
        </member>
        <member name="M:ReactiveUI.UnhandledInteractionException`2.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> class.
            </summary>
            <param name="message">A message about the exception.</param>
        </member>
        <member name="M:ReactiveUI.UnhandledInteractionException`2.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> class.
            </summary>
            <param name="message">A message about the exception.</param>
            <param name="innerException">Any other exception that caused the issue.</param>
        </member>
        <member name="M:ReactiveUI.UnhandledInteractionException`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> class.
            </summary>
            <param name="info">The serialization information.</param>
            <param name="context">The serialization context.</param>
        </member>
        <member name="P:ReactiveUI.UnhandledInteractionException`2.Interaction">
            <summary>
            Gets the interaction that was not handled.
            </summary>
        </member>
        <member name="P:ReactiveUI.UnhandledInteractionException`2.Input">
            <summary>
            Gets the input for the interaction that was not handled.
            </summary>
        </member>
        <member name="M:ReactiveUI.UnhandledInteractionException`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.BindingDirection">
            <summary>
            The type of binding that the ReactiveBinding represents.
            </summary>
        </member>
        <member name="F:ReactiveUI.BindingDirection.OneWay">
            <summary>The binding is updated only one way from the ViewModel.</summary>
        </member>
        <member name="F:ReactiveUI.BindingDirection.TwoWay">
            <summary>The binding is updated from both the View and the ViewModel.</summary>
        </member>
        <member name="F:ReactiveUI.BindingDirection.AsyncOneWay">
            <summary>The binding is updated asynchronously one way from the ViewModel.</summary>
        </member>
        <member name="T:ReactiveUI.IActivatable">
            <summary>
            Use this Interface when you want to mark a control as recieving View
            Activation when it doesn't have a backing ViewModel.
            </summary>
        </member>
        <member name="T:ReactiveUI.IBindingTypeConverter">
            <summary>
            This interface is the extensible implementation of IValueConverters for
            Bind and OneWayBind. Implement this to teach Bind and OneWayBind how to
            convert between types.
            </summary>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.GetAffinityForObjects(System.Type,System.Type)">
            <summary>
            Returns a positive integer when this class supports
            TryConvert for this particular Type. If the method isn't supported at
            all, return a non-positive integer. When multiple implementations
            return a positive value, the host will use the one which returns
            the highest value. When in doubt, return '2' or '0'.
            </summary>
            <param name="fromType">The source type to convert from.</param>
            <param name="toType">The target type to convert to.</param>
            <returns>A positive integer if TryConvert is supported,
            zero or a negative value otherwise.</returns>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.TryConvert(System.Object,System.Type,System.Object,System.Object@)">
            <summary>
            Convert a given object to the specified type.
            </summary>
            <param name="from">The object to convert.</param>
            <param name="toType">The type to coerce the object to.</param>
            <param name="conversionHint">An implementation-defined value,
            usually to specify things like locale awareness.</param>
            <param name="result">An object that is of the type <paramref name="toType"/>.</param>
            <returns>True if conversion was successful.</returns>
        </member>
        <member name="T:ReactiveUI.ICanActivate">
            <summary>
            This Interface is used by the framework to explicitly provide activation
            events. Usually you can ignore this unless you are porting RxUI to a new
            UI Toolkit.
            </summary>
        </member>
        <member name="P:ReactiveUI.ICanActivate.Activated">
            <summary>
            Gets a observable which is triggered when the ViewModel is activated.
            </summary>
        </member>
        <member name="P:ReactiveUI.ICanActivate.Deactivated">
            <summary>
            Gets a obervable which is triggered when the ViewModel is deactivated.
            </summary>
        </member>
        <member name="T:ReactiveUI.ICanForceManualActivation">
            <summary>
            Instead of using System events will allow for external classes to
            manually Activate the View object.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICanForceManualActivation.Activate(System.Boolean)">
            <summary>
            Activates the view object.
            </summary>
            <param name="activate">If we are activating or not.</param>
        </member>
        <member name="T:ReactiveUI.ICreatesCommandBinding">
            <summary>
            Classes that implement this interface and registered inside Splat will be
            used to potentially provide binding to a ICommand in the ViewModel to a Control
            in the View.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.GetAffinityForObject(System.Type,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports
            BindCommandToObject for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'.
            </summary>
            <param name="type">The type to query for.</param>
            <param name="hasEventTarget">If true, the host intends to use a custom
            event target.</param>
            <returns>A positive integer if BCTO is supported, zero or a negative
            value otherwise.</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object})">
            <summary>
            Bind an ICommand to a UI object, in the "default" way. The meaning
            of this is dependent on the implementation. Implement this if you
            have a new type of UI control that doesn't have
            Command/CommandParameter like WPF or has a non-standard event name
            for "Invoke".
            </summary>
            <param name="command">The command to bind.</param>
            <param name="target">The target object, usually a UI control of
            some kind.</param>
            <param name="commandParameter">An IObservable source whose latest
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be
            Observable.Empty.</param>
            <returns>An IDisposable which will disconnect the binding when
            disposed.</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject``1(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object},System.String)">
            <summary>
            Bind an ICommand to a UI object to a specific event. This event may
            be a standard .NET event, or it could be an event derived in another
            manner (i.e. in MonoTouch).
            </summary>
            <typeparam name="TEventArgs">The event argument type.</typeparam>
            <param name="command">The command to bind.</param>
            <param name="target">The target object, usually a UI control of
            some kind.</param>
            <param name="commandParameter">An IObservable source whose latest
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be
            Observable.Empty.</param>
            <param name="eventName">The event to bind to.</param>
            <returns>An IDisposable which will disconnect the binding when disposed.</returns>
        </member>
        <member name="T:ReactiveUI.ICreatesObservableForProperty">
            <summary>
            ICreatesObservableForProperty represents an object that knows how to
            create notifications for a given type of object. Implement this if you
            are porting RxUI to a new UI toolkit, or generally want to enable WhenAny
            for another type of object that can be observed in a unique way.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetAffinityForObject(System.Type,System.String,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports
            GetNotificationForProperty for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'.
            </summary>
            <param name="type">The type to query for.</param>
            <param name="propertyName">The property of the type to query for.</param>
            <param name="beforeChanged">If true, returns whether GNFP is supported before a change occurs.</param>
            <returns>A positive integer if GNFP is supported, zero or a negative
            value otherwise.</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetNotificationForProperty(System.Object,System.Linq.Expressions.Expression,System.String,System.Boolean)">
            <summary>
            Subscribe to notifications on the specified property, given an
            object and a property name.
            </summary>
            <param name="sender">The object to observe.</param>
            <param name="expression">The expression on the object to observe.
            This will be either a MemberExpression or an IndexExpression
            dependending on the property.
            </param>
            <param name="propertyName">The property of the type to query for.</param>
            <param name="beforeChanged">If true, signal just before the
            property value actually changes. If false, signal after the
            property changes.</param>
            <returns>An IObservable which is signalled whenever the specified
            property on the object changes. If this cannot be done for a
            specified value of beforeChanged, return Observable.Never.</returns>
        </member>
        <member name="T:ReactiveUI.IHandleObservableErrors">
             <summary>
             This interface is implemented by RxUI objects which are given
             IObservables as input - when the input IObservables OnError, instead of
             disabling the RxUI object, we catch the IObservable and pipe it into
             this property.
            
             Normally this IObservable is implemented with a ScheduledSubject whose
             default Observer is RxApp.DefaultExceptionHandler - this means, that if
             you aren't listening to ThrownExceptions and one appears, the exception
             will appear on the UI thread and crash the application.
             </summary>
        </member>
        <member name="P:ReactiveUI.IHandleObservableErrors.ThrownExceptions">
            <summary>
            Gets a observable which will fire whenever an exception would normally terminate ReactiveUI
            internal state.
            </summary>
        </member>
        <member name="T:ReactiveUI.IMessageBus">
             <summary>
             IMessageBus represents an object that can act as a "Message Bus", a
             simple way for ViewModels and other objects to communicate with each
             other in a loosely coupled way.
            
             Specifying which messages go where is done via a combination of the Type
             of the message as well as an additional "Contract" parameter; this is a
             unique string used to distinguish between messages of the same Type, and
             is arbitrarily set by the client.
             </summary>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at
            runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified
            runtime and contract, this will overrwrite the existing
            registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract.
            CurrentThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.IMessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An observable sequence.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            ListenIncludeLatest provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage and fire the
            last provided Message immediately if applicable, or null.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The type of the message.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>A disposable.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="T:ReactiveUI.IObservedChange`2">
            <summary>
            IObservedChange is a generic interface that is returned from WhenAny()
            Note that it is used for both Changing (i.e.'before change')
            and Changed Observables.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Sender">
            <summary>
            Gets the object that has raised the change.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Expression">
            <summary>
            Gets the expression of the member that has changed on Sender.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Value">
            <summary>
            Gets the value of the property that has changed. IMPORTANT NOTE: This
            property is often not set for performance reasons, unless you have
            explicitly requested an Observable for a property via a method such
            as ObservableForProperty. To retrieve the value for the property,
            use the GetValue() extension method.
            </summary>
        </member>
        <member name="T:ReactiveUI.IPlatformOperations">
            <summary>
            Additional details implemented by the different ReactiveUI platform projects.
            </summary>
        </member>
        <member name="M:ReactiveUI.IPlatformOperations.GetOrientation">
            <summary>
            Gets a descriptor that describes (if applicable) the orientation
            of the screen.
            </summary>
            <returns>The device orientation descriptor.</returns>
        </member>
        <member name="T:ReactiveUI.IPropertyBindingHook">
            <summary>
            Implement this as a way to intercept bindings at the time that they are
            created and execute an additional action (or to cancel the binding).
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBindingHook.ExecuteHook(System.Object,System.Object,System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},ReactiveUI.BindingDirection)">
            <summary>
            Called when any binding is set up.
            </summary>
            <returns>If false, the binding is cancelled.</returns>
            <param name="source">The source ViewModel.</param>
            <param name="target">The target View (not the actual control).</param>
            <param name="getCurrentViewModelProperties">Get current view model properties.</param>
            <param name="getCurrentViewProperties">Get current view properties.</param>
            <param name="direction">The Binding direction.</param>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyPropertyChanged`1">
            <summary>
            IReactiveNotifyPropertyChanged represents an extended version of
            INotifyPropertyChanged that also exposes typed Observables.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged`1.Changing">
            <summary>
            Gets an observable that fires *before* a property is about to
            be changed. Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged`1.Changed">
            <summary>
            Gets an Observable that fires *after* a property has changed.
            Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveNotifyPropertyChanged`1.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.IReactivePropertyChangedEventArgs`1">
            <summary>
            IReactivePropertyChangedEventArgs is a generic interface that
            is used to wrap the NotifyPropertyChangedEventArgs and gives
            information about changed properties. It includes also
            the sender of the notification.
            Note that it is used for both Changing (i.e.'before change')
            and Changed Observables.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
        </member>
        <member name="P:ReactiveUI.IReactivePropertyChangedEventArgs`1.PropertyName">
            <summary>
            Gets the name of the property that has changed on Sender.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactivePropertyChangedEventArgs`1.Sender">
            <summary>
            Gets the object that has raised the change.
            </summary>
        </member>
        <member name="T:ReactiveUI.IRoutableViewModel">
            <summary>
            Implement this interface for ViewModels that can be navigated to.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.UrlPathSegment">
            <summary>
            Gets a string token representing the current ViewModel, such as 'login' or 'user'.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.HostScreen">
            <summary>
            Gets the IScreen that this ViewModel is currently being shown in. This
            is usually passed into the ViewModel in the Constructor and saved
            as a ReadOnly Property.
            </summary>
        </member>
        <member name="T:ReactiveUI.IScreen">
            <summary>
            IScreen represents any object that is hosting its own routing -
            usually this object is your AppViewModel or MainWindow object.
            </summary>
        </member>
        <member name="P:ReactiveUI.IScreen.Router">
            <summary>
            Gets the Router associated with this Screen.
            </summary>
        </member>
        <member name="T:ReactiveUI.ISupportsActivation">
            <summary>
            Implementing this interface on a ViewModel indicates that the ViewModel
            is interested in Activation events. Instantiate the Activator, then call
            WhenActivated on your class to register what you want to happen when
            the View is activated. See the documentation for ViewModelActivator to
            read more about Activation.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISupportsActivation.Activator">
            <summary>
            Gets the Activator which will be used by the View when Activation/Deactivation occurs.
            </summary>
        </member>
        <member name="T:ReactiveUI.ISuspensionDriver">
            <summary>
            ISuspensionDriver represents a class that can load/save state to persistent
            storage. Most platforms have a basic implementation of this class, but you
            probably want to write your own.
            </summary>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.LoadState">
            <summary>
            Loads the application state from persistent storage.
            </summary>
            <returns>An object observable.</returns>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.SaveState(System.Object)">
            <summary>
            Saves the application state to disk.
            </summary>
            <param name="state">The application state.</param>
            <returns>A completed observable.</returns>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.InvalidateState">
            <summary>
            Invalidates the application state (i.e. deletes it from disk).
            </summary>
            <returns>A completed observable.</returns>
        </member>
        <member name="T:ReactiveUI.ISuspensionHost">
            <summary>
            ISuspensionHost represents a standardized version of the events that the
            host operating system publishes. Subscribe to these events in order to
            handle app suspend / resume.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsLaunchingNew">
            <summary>
            Gets or sets the observable which signals when the application is launching new. This can happen when
            an app has recently crashed, as well as the first time the app has
            been launched. Apps should create their state from scratch.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsResuming">
            <summary>
            Gets or sets the observable which signals when the application is resuming from suspended state (i.e.
            it was previously running but its process was destroyed).
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsUnpausing">
            <summary>
            Gets or sets the observable which signals when the application is activated. Note that this may mean
            that your process was not actively running before this signal.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.ShouldPersistState">
            <summary>
            Gets or sets the observable which signals when the application should persist its state to disk.
            </summary>
            <value>Returns an IDisposable that should be disposed once the
            application finishes persisting its state.</value>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.ShouldInvalidateState">
            <summary>
            Gets or sets the observable which signals that the saved application state should be deleted, this
            usually is called after an app has crashed.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.CreateNewAppState">
            <summary>
            Gets or sets a function that can be used to create a new application state - usually
            this method just calls 'new' on an object.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.AppState">
            <summary>
            Gets or sets the current application state - get a typed version of this via
            <see cref="M:ReactiveUI.SuspensionHostExtensions.GetAppState``1(ReactiveUI.ISuspensionHost)"/>.
            The "application state" is a notion entirely defined
            via the client application - the framework places no restrictions on
            the object other than it can be serialized.
            </summary>
        </member>
        <member name="T:ReactiveUI.IViewFor">
            <summary>
            This base class is mostly used by the Framework. Implement <see cref="T:ReactiveUI.IViewFor`1"/>
            instead.
            </summary>
        </member>
        <member name="P:ReactiveUI.IViewFor.ViewModel">
            <summary>
            Gets or sets the View Model associated with the View.
            </summary>
        </member>
        <member name="T:ReactiveUI.IViewFor`1">
            <summary>
            Implement this interface on your Views to support Routing and Binding.
            </summary>
            <typeparam name="T">The type of ViewModel.</typeparam>
        </member>
        <member name="P:ReactiveUI.IViewFor`1.ViewModel">
            <summary>
            Gets or sets the ViewModel corresponding to this specific View. This should be
            a DependencyProperty if you're using XAML.
            </summary>
        </member>
        <member name="T:ReactiveUI.IViewLocator">
            <summary>
            Implement this to override how RoutedViewHost and ViewModelViewHost
            map ViewModels to Views.
            </summary>
        </member>
        <member name="M:ReactiveUI.IViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Determines the view for an associated ViewModel.
            </summary>
            <typeparam name="T">The view model type.</typeparam>
            <returns>The view, with the ViewModel property assigned to
            viewModel.</returns>
            <param name="viewModel">View model.</param>
            <param name="contract">Contract.</param>
        </member>
        <member name="T:ReactiveUI.IWantsToRegisterStuff">
            <summary>
            Used by ReactiveUI when first starting up, it will seek out classes
            inside our own ReactiveUI projects. The implemented methods will
            register with Splat their dependencies.
            </summary>
        </member>
        <member name="M:ReactiveUI.IWantsToRegisterStuff.Register(System.Action{System.Func{System.Object},System.Type})">
            <summary>
            Register platform dependencies inside Splat.
            </summary>
            <param name="registerFunction">A method the deriving class will class to register the type.</param>
        </member>
        <member name="T:ReactiveUI.ObservedChange`2">
            <summary>
            A data-only version of IObservedChange.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="M:ReactiveUI.ObservedChange`2.#ctor(`0,System.Linq.Expressions.Expression,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ObservedChange`2"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="expression">Expression describing the member.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:ReactiveUI.ObservedChange`2.Sender">
            <summary>
            Gets the object which triggered the observed change.
            </summary>
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ObservedChange`2.Expression">
            <summary>
            Gets the Expression which was used to get the property changed value.
            </summary>
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ObservedChange`2.Value">
            <summary>
            Gets the new value after the change.
            </summary>
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.ReactivePropertyChangedEventArgs`1">
            <summary>
            Event arguments for when a property has changed.
            Expands on the PropertyChangedEventArgs to add the Sender.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
        </member>
        <member name="M:ReactiveUI.ReactivePropertyChangedEventArgs`1.#ctor(`0,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ReactivePropertyChangedEventArgs`1"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="P:ReactiveUI.ReactivePropertyChangedEventArgs`1.Sender">
            <summary>
            Gets the sender which triggered the property changed event.
            </summary>
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.ReactivePropertyChangingEventArgs`1">
            <summary>
            Event arguments for when a property is changing.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
        </member>
        <member name="M:ReactiveUI.ReactivePropertyChangingEventArgs`1.#ctor(`0,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ReactivePropertyChangingEventArgs`1"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="P:ReactiveUI.ReactivePropertyChangingEventArgs`1.Sender">
            <summary>
            Gets the sender which triggered the Reactive property changed event.
            </summary>
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.AutoPersistHelper">
            <summary>
            Helper extension method class associated with the AutoPersist related functionality.
            </summary>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersist``1(``0,System.Func{``0,System.IObservable{System.Reactive.Unit}},System.Nullable{System.TimeSpan})">
            <summary>
            AutoPersist allows you to automatically call a method when an object
            has changed, throttling on a certain interval. Note that this object
            must mark its persistable properties via the [DataMember] attribute.
            Changes to properties not marked with DataMember will not trigger the
            object to be saved.
            </summary>
            <typeparam name="T">The reactive object type.</typeparam>
            <param name="this">
            The reactive object to watch for changes.
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing,
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersist``2(``0,System.Func{``0,System.IObservable{System.Reactive.Unit}},System.IObservable{``1},System.Nullable{System.TimeSpan})">
            <summary>
            AutoPersist allows you to automatically call a method when an object
            has changed, throttling on a certain interval. Note that this object
            must mark its persistable properties via the [DataMember] attribute.
            Changes to properties not marked with DataMember will not trigger the
            object to be saved.
            </summary>
            <typeparam name="T">The reactive object type.</typeparam>
            <typeparam name="TDontCare">The save signal type.</typeparam>
            <param name="this">
            The reactive object to watch for changes.
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="manualSaveSignal">
            When invoked, the object will be saved regardless of whether it has changed.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing,
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersistCollection``1(System.Collections.ObjectModel.ObservableCollection{``0},System.Func{``0,System.IObservable{System.Reactive.Unit}},System.Nullable{System.TimeSpan})">
            <summary>
            Apply AutoPersistence to all objects in a collection. Items that are
            no longer in the collection won't be persisted anymore.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing,
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersistCollection``2(System.Collections.ObjectModel.ObservableCollection{``0},System.Func{``0,System.IObservable{System.Reactive.Unit}},System.IObservable{``1},System.Nullable{System.TimeSpan})">
            <summary>
            Apply AutoPersistence to all objects in a collection. Items that are
            no longer in the collection won't be persisted anymore.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <typeparam name="TDontCare">The return signal type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="manualSaveSignal">
            When invoked, the object will be saved regardless of whether it has changed.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing,
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersistCollection``2(System.Collections.ObjectModel.ReadOnlyObservableCollection{``0},System.Func{``0,System.IObservable{System.Reactive.Unit}},System.IObservable{``1},System.Nullable{System.TimeSpan})">
            <summary>
            Apply AutoPersistence to all objects in a collection. Items that are
            no longer in the collection won't be persisted anymore.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <typeparam name="TDontCare">The signal type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="manualSaveSignal">
            When invoked, the object will be saved regardless of whether it has changed.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing,
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersistCollection``3(``1,System.Func{``0,System.IObservable{System.Reactive.Unit}},System.IObservable{``2},System.Nullable{System.TimeSpan})">
            <summary>
            Apply AutoPersistence to all objects in a collection. Items that are
            no longer in the collection won't be persisted anymore.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <typeparam name="TCollection">The collection type.</typeparam>
            <typeparam name="TDontCare">The signal type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="manualSaveSignal">
            When invoked, the object will be saved regardless of whether it has changed.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing,
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.ActOnEveryObject``1(System.Collections.ObjectModel.ObservableCollection{``0},System.Action{``0},System.Action{``0})">
            <summary>
            Call methods 'onAdd' and 'onRemove' whenever an object is added or
            removed from a collection. This class correctly handles both when
            a collection is initialized, as well as when the collection is Reset.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="onAdd">
            A method to be called when an object is added to the collection.
            </param>
            <param name="onRemove">
            A method to be called when an object is removed from the collection.
            </param>
            <returns>A Disposable that deactivates this behavior.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.ActOnEveryObject``1(System.Collections.ObjectModel.ReadOnlyObservableCollection{``0},System.Action{``0},System.Action{``0})">
            <summary>
            Call methods 'onAdd' and 'onRemove' whenever an object is added or
            removed from a collection. This class correctly handles both when
            a collection is initialized, as well as when the collection is Reset.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="onAdd">
            A method to be called when an object is added to the collection.
            </param>
            <param name="onRemove">
            A method to be called when an object is removed from the collection.
            </param>
            <returns>A Disposable that deactivates this behavior.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.ActOnEveryObject``2(``1,System.Action{``0},System.Action{``0})">
            <summary>
            Call methods 'onAdd' and 'onRemove' whenever an object is added or
            removed from a collection. This class correctly handles both when
            a collection is initialized, as well as when the collection is Reset.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <typeparam name="TCollection">The collection type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="onAdd">
            A method to be called when an object is added to the collection.
            </param>
            <param name="onRemove">
            A method to be called when an object is removed from the collection.
            </param>
            <returns>A Disposable that deactivates this behavior.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.ActOnEveryObject``1(System.IObservable{DynamicData.IChangeSet{``0}},System.Action{``0},System.Action{``0})">
            <summary>
            Call methods 'onAdd' and 'onRemove' whenever an object is added or
            removed from a collection. This class correctly handles both when
            a collection is initialized, as well as when the collection is Reset.
            </summary>
            <typeparam name="TItem">The item type.</typeparam>
            <param name="this">
            The reactive collection to watch for changes.
            </param>
            <param name="onAdd">
            A method to be called when an object is added to the collection.
            </param>
            <param name="onRemove">
            A method to be called when an object is removed from the collection.
            </param>
            <returns>A Disposable that deactivates this behavior.</returns>
        </member>
        <member name="T:ReactiveUI.ChangeSetMixin">
            <summary>
            Mixin associated with the DynamicData IChangeSet class.
            </summary>
        </member>
        <member name="M:ReactiveUI.ChangeSetMixin.HasCountChanged(DynamicData.IChangeSet)">
            <summary>
            Is the change set associated with a count change.
            </summary>
            <param name="changeSet">The change list to evaluate.</param>
            <returns>If the change set is caused by the count being changed.</returns>
        </member>
        <member name="M:ReactiveUI.ChangeSetMixin.CountChanged(System.IObservable{DynamicData.IChangeSet})">
            <summary>
            Is the change set associated with a count change.
            </summary>
            <param name="changeSet">The change list to evaluate.</param>
            <returns>An observable of changes that only have count changes.</returns>
        </member>
        <member name="M:ReactiveUI.ChangeSetMixin.CountChanged``1(System.IObservable{DynamicData.IChangeSet{``0}})">
            <summary>
            Is the change set associated with a count change.
            </summary>
            <typeparam name="T">The change set type.</typeparam>
            <param name="changeSet">The change list to evaluate.</param>
            <returns>An observable of changes that only have count changes.</returns>
        </member>
        <member name="T:ReactiveUI.DependencyResolverMixins">
            <summary>
            Extension methods associated with the IMutableDependencyResolver interface.
            </summary>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.InitializeReactiveUI(Splat.IMutableDependencyResolver)">
            <summary>
            This method allows you to initialize resolvers with the default
            ReactiveUI types. All resolvers used as the default
            Locator.Current.
            </summary>
            <param name="resolver">The resolver to initialize.</param>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.RegisterViewsForViewModels(Splat.IMutableDependencyResolver,System.Reflection.Assembly)">
            <summary>
            Registers inside the Splat dependency container all the classes that derive off
            IViewFor using Reflection. This is a easy way to register all the Views
            that are associated with View Models for an entire assembly.
            </summary>
            <param name="resolver">The dependency injection resolver to register the Views with.</param>
            <param name="assembly">The assembly to search using reflection for IViewFor classes.</param>
        </member>
        <member name="T:ReactiveUI.ExpressionMixins">
            <summary>
            Extension methods associated with the Expression class.
            </summary>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetExpressionChain(System.Linq.Expressions.Expression)">
            <summary>
            Gets all the chain of child expressions within a Expression.
            Handles property member accesses, objects and indexes.
            </summary>
            <param name="this">The expression.</param>
            <returns>An enumerable of expressions.</returns>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetMemberInfo(System.Linq.Expressions.Expression)">
            <summary>
            Gets the MemberInfo where a Expression is pointing towards.
            Can handle MemberAccess and Index types and will handle
            going through the Conversion Expressions.
            </summary>
            <param name="expression">The expression.</param>
            <returns>The member info from the epxression.</returns>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetParent(System.Linq.Expressions.Expression)">
            <summary>
            Gets the parent Expression of the current Expression object.
            </summary>
            <param name="expression">The expression.</param>
            <returns>The parent expression.</returns>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetArgumentsArray(System.Linq.Expressions.Expression)">
            <summary>
            For a Expression which is a Index type, will get all the arguments passed to the indexer.
            Useful for when you are attempting to find the indexer when a constant value is passed in.
            </summary>
            <param name="expression">The expression.</param>
            <returns>An array of arguments.</returns>
        </member>
        <member name="T:ReactiveUI.ObservableLoggingMixin">
            <summary>
            Extension methods to assist with Logging.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableLoggingMixin.Log``2(System.IObservable{``0},``1,System.String,System.Func{``0,System.String})">
            <summary>
            Logs an Observable to Splat's Logger.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TObj">The object type.</typeparam>
            <param name="this">The source observable to log to splat.</param>
            <param name="klass">The hosting class, usually 'this'.</param>
            <param name="message">An optional method.</param>
            <param name="stringifier">An optional Func to convert Ts to strings.</param>
            <returns>The same Observable.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableLoggingMixin.LoggedCatch``2(System.IObservable{``0},``1,System.IObservable{``0},System.String)">
            <summary>
            Like Catch, but also prints a message and the error to the log.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TObj">The object type.</typeparam>
            <param name="this">The source observable to log to splat.</param>
            <param name="klass">The hosting class, usually 'this'.</param>
            <param name="next">The Observable to replace the current one OnError.</param>
            <param name="message">An error message to print.</param>
            <returns>The same Observable.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableLoggingMixin.LoggedCatch``3(System.IObservable{``0},``1,System.Func{``2,System.IObservable{``0}},System.String)">
            <summary>
            Like Catch, but also prints a message and the error to the log.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TObj">The object type.</typeparam>
            <typeparam name="TException">The exception type.</typeparam>
            <param name="this">The source observable to log to splat.</param>
            <param name="klass">The hosting class, usually 'this'.</param>
            <param name="next">A Func to create an Observable to replace the
            current one OnError.</param>
            <param name="message">An error message to print.</param>
            <returns>The same Observable.</returns>
        </member>
        <member name="T:ReactiveUI.ObservedChangedMixin">
            <summary>
            A collection of helpers for <see cref="T:ReactiveUI.IObservedChange`2"/>.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.GetPropertyName``2(ReactiveUI.IObservedChange{``0,``1})">
            <summary>
            Returns the name of a property which has been changed.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="this">The observed change.</param>
            <returns>
            The name of the property which has changed.
            </returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.GetValue``2(ReactiveUI.IObservedChange{``0,``1})">
            <summary>
            Returns the current value of a property given a notification that
            it has changed.
            </summary>
            <typeparam name="TSender">The sender.</typeparam>
            <typeparam name="TValue">The changed value.</typeparam>
            <param name="this">
            The <see cref="T:ReactiveUI.IObservedChange`2"/> instance to get the value of.
            </param>
            <returns>
            The current value of the property.
            </returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.Value``2(System.IObservable{ReactiveUI.IObservedChange{``0,``1}})">
            <summary>
            Given a stream of notification changes, this method will convert
            the property changes to the current value of the property.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="this">
            The change notification stream to get the values of.
            </param>
            <returns>
            An Observable representing the stream of current values of
            the given change notification stream.
            </returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.TryGetValue``2(ReactiveUI.IObservedChange{``0,``1},``1@)">
            <summary>
            Attempts to return the current value of a property given a
            notification that it has changed. If any property in the
            property expression is null, false is returned.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="this">
            The <see cref="T:ReactiveUI.IObservedChange`2"/> instance to get the value of.
            </param>
            <param name="changeValue">
            The value of the property expression.
            </param>
            <returns>
            True if the entire expression was able to be followed, false otherwise.
            </returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.SetValueToProperty``3(ReactiveUI.IObservedChange{``0,``1},``2,System.Linq.Expressions.Expression{System.Func{``2,``1}})">
            <summary>
            Given a fully filled-out IObservedChange object, SetValueToProperty
            will apply it to the specified object (i.e. it will ensure that
            target.property == This.GetValue() and "replay" the observed change
            onto another object).
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <param name="this">
            The <see cref="T:ReactiveUI.IObservedChange`2"/> instance to use as a
            value to apply.
            </param>
            <param name="target">
            The target object to apply the change to.
            </param>
            <param name="property">
            The target property to apply the change to.
            </param>
        </member>
        <member name="T:ReactiveUI.ReactiveNotifyPropertyChangedMixin">
            <summary>
            Extension methods associated with the Observable Changes and the
            Reactive Notify Property Changed based events.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject. This method (unlike other Observables that return
            IObservedChange) guarantees that the Value property of
            the IObservedChange is set.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <param name="this">The source object to observe properties of.</param>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty.SomeOtherProperty'.</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <param name="skipInitial">If true, the Observable will not notify
            with the initial value.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1,``2},System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject, running the IObservedChange through a Selector
            function.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
            <typeparam name="TRet">The return value type.</typeparam>
            <param name="this">The source object to observe properties of.</param>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty'.</param>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.SubscribeToExpressionChain``2(``0,System.Linq.Expressions.Expression,System.Boolean,System.Boolean)">
            <summary>
            Creates a observable which will subscribe to the each property and sub property
            specified in the Expression. eg It will subscribe to x => x.Property1.Property2.Property3
            each property in the lambda expression. It will then provide updates to the last value in the chain.
            </summary>
            <param name="source">The object where we start the chain.</param>
            <param name="expression">A expression which will point towards the property.</param>
            <param name="beforeChange">If we are interested in notifications before the property value is changed.</param>
            <param name="skipInitial">If we don't want to get a notification about the default value of the property.</param>
            <typeparam name="TSender">The type of the origin of the expression chain.</typeparam>
            <typeparam name="TValue">The end value we want to subscribe to.</typeparam>
            <returns>A observable which notifies about observed changes.</returns>
            <exception cref="T:System.InvalidCastException">If we cannot cast from the target value from the specified last property.</exception>
        </member>
        <member name="T:ReactiveUI.INPCObservableForProperty">
            <summary>
            Generates Observables based on observing INotifyPropertyChanged objects.
            </summary>
        </member>
        <member name="M:ReactiveUI.INPCObservableForProperty.GetAffinityForObject(System.Type,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.INPCObservableForProperty.GetNotificationForProperty(System.Object,System.Linq.Expressions.Expression,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.IROObservableForProperty">
            <summary>
            Generates Observables based on observing Reactive objects.
            </summary>
        </member>
        <member name="M:ReactiveUI.IROObservableForProperty.GetAffinityForObject(System.Type,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.IROObservableForProperty.GetNotificationForProperty(System.Object,System.Linq.Expressions.Expression,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.OAPHCreationHelperMixin">
            <summary>
            A collection of helpers to aid working with observable properties.
            </summary>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.
            </summary>
            <typeparam name="TObj">The onject type.</typeparam>
            <typeparam name="TRet">The result type.</typeparam>
            <param name="target">
            The observable to convert to an ObservableAsPropertyHelper.
            </param>
            <param name="source">
            The ReactiveObject that has the property.
            </param>
            <param name="property">
            An Expression representing the property (i.e. <c>x => x.SomeProperty</c>).
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/>
            should defer the subscription to the <paramref name="target"/> source
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>,
            or if it should immediately subscribe to the the <paramref name="target"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should normally
            be a Dispatcher-based scheduler.
            </param>
            <returns>
            An initialized ObservableAsPropertyHelper; use this as the backing field
            for your property.
            </returns>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},ReactiveUI.ObservableAsPropertyHelper{``1}@,``1,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.
            </summary>
            <typeparam name="TObj">The onject type.</typeparam>
            <typeparam name="TRet">The result type.</typeparam>
            <param name="target">
            The observable to convert to an ObservableAsPropertyHelper.
            </param>
            <param name="source">
            The ReactiveObject that has the property.
            </param>
            <param name="property">
            An Expression representing the property (i.e. <c>x => x.SomeProperty</c>).
            </param>
            <param name="result">
            An out param matching the return value, provided for convenience.
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/>
            should defer the subscription to the <paramref name="target"/> source
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>,
            or if it should immediately subscribe to the the <paramref name="target"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should
            normally be a Dispatcher-based scheduler.
            </param>
            <returns>
            An initialized ObservableAsPropertyHelper; use this as the backing
            field for your property.
            </returns>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.String,``1,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.
            </summary>
            <typeparam name="TObj">The onject type.</typeparam>
            <typeparam name="TRet">The result type.</typeparam>
            <param name="target">
            The observable to convert to an ObservableAsPropertyHelper.
            </param>
            <param name="source">
            The ReactiveObject that has the property.
            </param>
            <param name="property">
            The name of the property that has changed. Recommended for use with nameof() or a FODY.
            or a fody.
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/>
            should defer the subscription to the <paramref name="target"/> source
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>,
            or if it should immediately subscribe to the the <paramref name="target"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should normally
            be a Dispatcher-based scheduler.
            </param>
            <returns>
            An initialized ObservableAsPropertyHelper; use this as the backing field
            for your property.
            </returns>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.String,ReactiveUI.ObservableAsPropertyHelper{``1}@,``1,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.
            </summary>
            <typeparam name="TObj">The onject type.</typeparam>
            <typeparam name="TRet">The result type.</typeparam>
            <param name="target">
            The observable to convert to an ObservableAsPropertyHelper.
            </param>
            <param name="source">
            The ReactiveObject that has the property.
            </param>
            <param name="property">
            The name of the property that has changed. Recommended for use with nameof() or a FODY.
            </param>
            <param name="result">
            An out param matching the return value, provided for convenience.
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/>
            should defer the subscription to the <paramref name="target"/> source
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>,
            or if it should immediately subscribe to the the <paramref name="target"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should
            normally be a Dispatcher-based scheduler.
            </param>
            <returns>
            An initialized ObservableAsPropertyHelper; use this as the backing
            field for your property.
            </returns>
        </member>
        <member name="T:ReactiveUI.ObservableAsPropertyHelper`1">
            <summary>
            ObservableAsPropertyHelper is a class to help ViewModels implement
            "output properties", that is, a property that is backed by an
            Observable. The property will be read-only, but will still fire change
            notifications. This class can be created directly, but is more often created
            via the <see cref="T:ReactiveUI.OAPHCreationHelperMixin" /> extension methods.
            </summary>
            <typeparam name="T">The type.</typeparam>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.#ctor(System.IObservable{`0},System.Action{`0},`0,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/> class.
            </summary>
            <param name="observable">
            The Observable to base the property on.
            </param>
            <param name="onChanged">
            The action to take when the property changes, typically this will call the
            ViewModel's RaisePropertyChanged method.
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/>
            should defer the subscription to the <paramref name="observable"/> source
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>, or if it should immediately
            subscribe to the the <paramref name="observable"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on -
            this should normally be a Dispatcher-based scheduler.
            </param>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.#ctor(System.IObservable{`0},System.Action{`0},System.Action{`0},`0,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/> class.
            </summary>
            <param name="observable">
            The Observable to base the property on.
            </param>
            <param name="onChanged">
            The action to take when the property changes, typically this will call
            the ViewModel's RaisePropertyChanged method.
            </param>
            <param name="onChanging">
            The action to take when the property changes, typically this will call
            the ViewModel's RaisePropertyChanging method.
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/>
            should defer the subscription to the <paramref name="observable"/> source
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>, or if it should immediately
            subscribe to the the <paramref name="observable"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will provided on - this
            should normally be a Dispatcher-based scheduler.
            </param>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.Value">
            <summary>
            Gets the last provided value from the Observable.
            </summary>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.IsSubscribed">
            <summary>
            Gets a value indicating whether the ObservableAsPropertyHelper
            has subscribed to the source Observable.
            Useful for scenarios where you use deferred subscription and want to know if
            the ObservableAsPropertyHelper Value has been accessed yet.
            </summary>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.ThrownExceptions">
            <summary>
            Gets an observable which signals whenever an exception would normally terminate ReactiveUI
            internal state.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.Default(`0,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs a "default" ObservableAsPropertyHelper object. This is
            useful for when you will initialize the OAPH later, but don't want
            bindings to access a null OAPH at startup.
            </summary>
            <param name="initialValue">
            The initial (and only) value of the property.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should
            normally be a Dispatcher-based scheduler.
            </param>
            <returns>A default property helper.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.Dispose">
            <summary>
            Disposes this ObservableAsPropertyHelper.
            </summary>
        </member>
        <member name="T:ReactiveUI.POCOObservableForProperty">
            <summary>
            This class is the final fallback for WhenAny, and will simply immediately
            return the value of the type at the time it was created. It will also
            warn the user that this is probably not what they want to do.
            </summary>
        </member>
        <member name="M:ReactiveUI.POCOObservableForProperty.GetAffinityForObject(System.Type,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.POCOObservableForProperty.GetNotificationForProperty(System.Object,System.Linq.Expressions.Expression,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.CombinedReactiveCommand`2">
            <summary>
            Encapsulates a composite user interaction.
            </summary>
            <remarks>
            <para>
            This class provides the bulk of the actual implementation for combined reactive commands. You should not
            create instances of this class directly, but rather via the static creation methods on the non-generic
            <see cref="T:ReactiveUI.ReactiveCommand"/> class.
            </para>
            <para>
            A <c>CombinedReactiveCommand</c> combines multiple reactive commands into a single command. Executing
            the combined command executes all child commands. Since all child commands will receive the same execution
            parameter, all child commands must accept a parameter of the same type.
            </para>
            <para>
            In order for the combined command to be executable, all child commands must themselves be executable.
            In addition, any <c>canExecute</c> observable passed in during construction must also yield <c>true</c>.
            </para>
            </remarks>
            <typeparam name="TParam">
            The type of parameter values passed in during command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the values that are the result of command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.CombinedReactiveCommand`2.#ctor(System.Collections.Generic.IEnumerable{ReactiveUI.ReactiveCommandBase{`0,`1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.CombinedReactiveCommand`2"/> class.
            </summary>
            <param name="childCommands">The child commands which will be executed.</param>
            <param name="canExecute">A observable when the command can be executed.</param>
            <param name="outputScheduler">The scheduler where to dispatch the output from the command.</param>
            <exception cref="T:System.ArgumentNullException">Fires when required arguments are null.</exception>
            <exception cref="T:System.ArgumentException">Fires if the child commands container is empty.</exception>
        </member>
        <member name="P:ReactiveUI.CombinedReactiveCommand`2.CanExecute">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.CombinedReactiveCommand`2.IsExecuting">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.CombinedReactiveCommand`2.ThrownExceptions">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CombinedReactiveCommand`2.Subscribe(System.IObserver{System.Collections.Generic.IList{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CombinedReactiveCommand`2.Execute(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CombinedReactiveCommand`2.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.IReactiveCommand">
            <summary>
            Encapsulates a user action behind a reactive interface.
            This is for interop inside for the command binding.
            Not meant for external use due to the fact it doesn't implement ICommand
            to force the user to favor the Reactive style command execution.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCommand.IsExecuting">
            <summary>
            Gets an observable whose value indicates whether the command is currently executing.
            </summary>
            <remarks>
            This observable can be particularly useful for updating UI, such as showing an activity indicator whilst a command
            is executing.
            </remarks>
        </member>
        <member name="P:ReactiveUI.IReactiveCommand.CanExecute">
            <summary>
            Gets an observable whose value indicates whether the command can currently execute.
            </summary>
            <remarks>
            The value provided by this observable is governed both by any <c>canExecute</c> observable provided during
            command creation, as well as the current execution status of the command. A command that is currently executing
            will always yield <c>false</c> from this observable, even if the <c>canExecute</c> pipeline is currently <c>true</c>.
            </remarks>
        </member>
        <member name="T:ReactiveUI.ReactiveCommand">
             <summary>
             Encapsulates a user action behind a reactive interface.
             </summary>
             <remarks>
             <para>
             This non-generic base class defines the creation behavior of the ReactiveCommand's.
             </para>
             <para>
             <see cref="T:ReactiveUI.ReactiveCommand`2"/> adds the concept of Input and Output generic types.
             The Input is often passed in by the View and it's type is captured as TInput, and the Output is
             the result of executing the command which type is captured as TOutput.
             </para>
             <para>
             <see cref="T:ReactiveUI.ReactiveCommand`2"/> is <c>IObservable</c> which can be used like any other <c>IObservable</c>.
             For example, you can Subscribe() to it like any other observable, and add the output to a List on your view model.
             The Unit type is a functional programming construct analogous to void and can be used in cases where you don't
             care about either the input and/or output value.
             </para>
             <para>
             Creating synchronous reactive commands:
             <code>
             <![CDATA[
             // A synchronous command taking a parameter and returning nothing.
             var command = ReactiveCommand.Create<int, Unit>(x => Console.WriteLine(x));
            
             // This outputs 42 to console.
             command.Execute(42).Subscribe();
            
             // A better approach is to invoke a command in response to an Observable<T>.
             // InvokeCommand operator respects the command's executability. That is, if
             // the command's CanExecute method returns false, InvokeCommand will not
             // execute the command when the source observable ticks.
             Observable.Return(42).InvokeCommand(command);
             ]]>
             </code>
             </para>
             <para>
             Creating asynchronous reactive commands:
             <code>
             <![CDATA[
             // An asynchronous command that waits 2 seconds and returns 42.
             var command = ReactiveCommand.CreateFromObservable<Unit, int>(
                  () => Observable.Return(42).Delay(TimeSpan.FromSeconds(2))
             );
            
             // Calling the asynchronous reactive command:
             // Observable.Return(Unit.Default).InvokeCommand(command);
            
             // Subscribing to values emitted by the command:
             command.Subscribe(Console.WriteLine);
             ]]>
             </code>
             </para>
             </remarks>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create(System.Action,System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic.
            </summary>
            <param name="execute">
            The action to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create``1(System.Func{``0},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic that returns a value
            of type <typeparamref name="TResult"/>.
            </summary>
            <param name="execute">
            The function to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of value returned by command executions.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create``1(System.Action{``0},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            The action to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create``2(System.Func{``0,``1},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>
            and returns a value of type <typeparamref name="TResult"/>.
            </summary>
            <param name="execute">
            The function to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of value returned by command executions.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromObservable``1(System.Func{System.IObservable{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides an observable representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{System.Threading.Tasks.Task{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless, cancellable <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask(System.Func{System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless, cancellable <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromObservable``2(System.Func{``0,System.IObservable{``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides an observable representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``2(System.Func{``0,System.Threading.Tasks.Task{``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``2(System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous, cancellable execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{``0,System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous, cancellable execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateCombined``2(System.Collections.Generic.IEnumerable{ReactiveUI.ReactiveCommandBase{``0,``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.CombinedReactiveCommand`2"/> that composes all the provided child commands.
            </summary>
            <param name="childCommands">
            The child commands that the combined command will compose.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution (in addition to the availability specified
            by each individual child command).
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>CombinedReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="T:ReactiveUI.ReactiveCommand`2">
            <summary>
            Encapsulates a user interaction behind a reactive interface.
            </summary>
            <remarks>
            <para>
            This class provides the bulk of the actual implementation for reactive commands. You should not create instances
            of this class directly, but rather via the static creation methods on the non-generic <see cref="T:ReactiveUI.ReactiveCommand"/>
            class.
            </para>
            </remarks>
            <typeparam name="TParam">
            The type of parameter values passed in during command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the values that are the result of command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand`2.#ctor(System.Func{`0,System.IObservable{`1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ReactiveCommand`2"/> class.
            </summary>
            <param name="execute">The Func to perform when the command is executed.</param>
            <param name="canExecute">A observable which has a value if the command can execute.</param>
            <param name="outputScheduler">The scheduler where to send output after the main execution.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if any dependent parameters are null.</exception>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand`2.CanExecute">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand`2.IsExecuting">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand`2.ThrownExceptions">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand`2.Subscribe(System.IObserver{`1})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand`2.Execute(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand`2.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.ReactiveCommandBase`2">
            <summary>
            A base class for generic reactive commands.
            </summary>
            <remarks>
            <para>
            This class extends <see cref="T:ReactiveUI.ReactiveCommand"/> and adds generic type parameters for the parameter values passed
            into command execution, and the return values of command execution.
            </para>
            <para>
            Because the result type is known by this class, it can implement <see cref="T:System.IObservable`1"/>. However, the implementation
            is defined as abstract, so subclasses must provide it.
            </para>
            <para>
            Reactive commands encapsulate the behavior of running some execution logic and then surfacing the results on the UI
            thread. Importantly, no scheduling is performed against input observables (the <c>canExecute</c> and execution pipelines).
            </para>
            <para>
            To create an instance of <c>ReactiveCommand</c>, call one of the static creation methods defined by this class.
            <see cref="M:ReactiveUI.ReactiveCommand.Create(System.Action,System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)"/> can be used when your execution logic is synchronous.
            <see cref="M:ReactiveUI.ReactiveCommand.CreateFromObservable``1(System.Func{System.IObservable{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)"/> and
            <see cref="M:ReactiveUI.ReactiveCommand.CreateFromTask(System.Func{System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)"/> (and overloads) can be used for asynchronous
            execution logic. Optionally, you can provide an observable that governs the availability of the command for execution,
            as well as a scheduler to which events will be delivered.
            </para>
            <para>
            The <see cref="P:ReactiveUI.ReactiveCommandBase`2.CanExecute"/> property provides an observable that can be used to determine whether the command is
            eligible for execution. The value of this observable is determined by both the <c>canExecute</c> observable provided
            during command creation, and the current execution status of the command. A command that is already executing will
            yield <c>false</c> from its <see cref="P:ReactiveUI.ReactiveCommandBase`2.CanExecute"/> observable regardless of the <c>canExecute</c> observable provided
            during command creation.
            </para>
            <para>
            The <see cref="P:ReactiveUI.ReactiveCommandBase`2.IsExecuting"/> property provides an observable whose value indicates whether the command is currently
            executing. This can be a useful means of triggering UI, such as displaying an activity indicator whilst a command is
            executing.
            </para>
            <para>
            As discussed above, you are under no obligation to somehow incorporate this into your <c>canExecute</c> observable
            because that is taken care of for you. That is, if the value of <c>IsExecuting</c> is <c>true</c>, the value of
            <c>CanExecute</c> will be <c>false</c>. However, if the value of <c>CanExecute</c> is <c>false</c>, that does not imply
            the value of <c>IsExecuting</c> is <c>true</c>.
            </para>
            <para>
            Any errors in your command's execution logic (including any <c>canExecute</c> observable you choose to provide) will be
            surfaced via the <see cref="P:ReactiveUI.ReactiveCommandBase`2.ThrownExceptions"/> observable. This gives you the opportunity to handle the error before
            it triggers a default handler that tears down the application. For example, you might use this as a means of alerting
            the user that something has gone wrong executing the command.
            </para>
            <para>
            For the sake of convenience, all <c>ReactiveCommand</c> instances are also implementations of <see cref="T:System.Windows.Input.ICommand"/>.
            This allows you to easily integrate instances of <c>ReactiveCommand</c> into platforms that understands <c>ICommand</c>
            natively (such as WPF and UWP).
            </para>
            </remarks>
            <typeparam name="TParam">
            The type of parameter values passed in during command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the values that are the result of command execution.
            </typeparam>
        </member>
        <member name="E:ReactiveUI.ReactiveCommandBase`2.System#Windows#Input#ICommand#CanExecuteChanged">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ReactiveCommandBase`2.CanExecute">
            <summary>
            Gets an observable whose value indicates whether the command can currently execute.
            </summary>
            <remarks>
            The value provided by this observable is governed both by any <c>canExecute</c> observable provided during
            command creation, as well as the current execution status of the command. A command that is currently executing
            will always yield <c>false</c> from this observable, even if the <c>canExecute</c> pipeline is currently <c>true</c>.
            </remarks>
        </member>
        <member name="P:ReactiveUI.ReactiveCommandBase`2.IsExecuting">
            <summary>
            Gets an observable whose value indicates whether the command is currently executing.
            </summary>
            <remarks>
            This observable can be particularly useful for updating UI, such as showing an activity indicator whilst a command
            is executing.
            </remarks>
        </member>
        <member name="P:ReactiveUI.ReactiveCommandBase`2.ThrownExceptions">
            <summary>
            Gets an observable that ticks any exceptions in command execution logic.
            </summary>
            <remarks>
            Any exceptions that are not observed via this observable will propagate out and cause the application to be torn
            down. Therefore, you will always want to subscribe to this observable if you expect errors could occur (e.g. if
            your command execution includes network activity).
            </remarks>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.Dispose">
            <inheritdoc />
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.System#Windows#Input#ICommand#CanExecute(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.System#Windows#Input#ICommand#Execute(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.Subscribe(System.IObserver{`1})">
            <summary>
            Subscribes to execution results from this command.
            </summary>
            <param name="observer">
            The observer.
            </param>
            <returns>
            An <see cref="T:System.IDisposable"/> that, when disposed, will unsubscribe the observer.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.Execute(`0)">
            <summary>
            Gets an observable that, when subscribed, executes this command.
            </summary>
            <remarks>
            <para>
            Invoking this method will return a cold (lazy) observable that, when subscribed, will execute the logic
            encapsulated by the command. It is worth restating that the returned observable is lazy. Nothing will
            happen if you call <c>Execute</c> and neglect to subscribe (directly or indirectly) to the returned observable.
            </para>
            <para>
            If no parameter value is provided, a default value of type <typeparamref name="TParam"/> will be passed into
            the execution logic.
            </para>
            <para>
            Any number of subscribers can subscribe to a given execution observable and the execution logic will only
            run once. That is, the result is broadcast to those subscribers.
            </para>
            <para>
            In those cases where execution fails, there will be no result value. Instead, the failure will tick through the
            <see cref="P:ReactiveUI.ReactiveCommandBase`2.ThrownExceptions"/> observable.
            </para>
            </remarks>
            <param name="parameter">
            The parameter to pass into command execution.
            </param>
            <returns>
            An observable that will tick the single result value if and when it becomes available.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.Dispose(System.Boolean)">
            <summary>
            Disposes of the managed resources.
            </summary>
            <param name="disposing">If its getting called by the Dispose() method.</param>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.OnCanExecuteChanged">
            <summary>
            Will trigger a event when the CanExecute condition has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.ICommandCanExecute(System.Object)">
            <summary>
            Will be called by the methods from the ICommand interface.
            This method is called when the Command should evaluate if it can execute.
            </summary>
            <param name="parameter">The parameter being passed to the ICommand.</param>
            <returns>If the command can be executed.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.ICommandExecute(System.Object)">
            <summary>
            Will be called by the methods from the ICommand interface.
            This method is called when the Command should execute.
            </summary>
            <param name="parameter">The parameter being passed to the ICommand.</param>
        </member>
        <member name="T:ReactiveUI.ReactiveCommandMixins">
            <summary>
            Extension methods associated with the ReactiveCommand class.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``1(System.IObservable{``0},System.Windows.Input.ICommand)">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called).
            </summary>
            <typeparam name="T">The type.</typeparam>
            <param name="this">The source observable to pipe into the command.</param>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},ReactiveUI.ReactiveCommandBase{``0,``1})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called).
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="this">The source observable to pipe into the command.</param>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,System.Windows.Input.ICommand}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called).
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <param name="this">The source observable to pipe into the command.</param>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``3(System.IObservable{``0},``2,System.Linq.Expressions.Expression{System.Func{``2,ReactiveUI.ReactiveCommandBase{``0,``1}}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called).
            </summary>
            <typeparam name="T">The type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <param name="this">The source observable to pipe into the command.</param>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="T:ReactiveUI.IReactiveObject">
            <summary>
            A reactive object is a interface for ViewModels which will expose
            logging, and notify when properties are either changing or changed.
            The primary use of this interface is to allow external classes such as
            the ObservableAsPropertyHelper to trigger these events inside the ViewModel.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveObject.RaisePropertyChanging(ReactiveUI.PropertyChangingEventArgs)">
            <summary>
            Raise a property is changing event.
            </summary>
            <param name="args">The arguments with details about the property that is changing.</param>
        </member>
        <member name="M:ReactiveUI.IReactiveObject.RaisePropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raise a property has changed event.
            </summary>
            <param name="args">The arguments with details about the property that has changed.</param>
        </member>
        <member name="T:ReactiveUI.IReactiveObjectExtensions">
            <summary>
            Extension methods associated with the IReactiveObject interface.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1">
            <summary>
            Contains the state information about the current status of a Reactive Object.
            </summary>
            <typeparam name="TSender">The type of the sender of the property changes.</typeparam>
        </member>
        <member name="P:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.Changing">
            <summary>
            Gets an observable for when a property is changing.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.Changed">
            <summary>
            Gets an observable for when the property has changed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.ThrownExceptions">
            <summary>
            Gets a observable when a exception is thrown.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.RaisePropertyChanging(System.String)">
            <summary>
            Raises a property changing event.
            </summary>
            <param name="propertyName">The name of the property that is changing.</param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.RaisePropertyChanged(System.String)">
            <summary>
            Raises a property changed event.
            </summary>
            <param name="propertyName">The name of the property that has changed.</param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.AreChangeNotificationsEnabled">
            <summary>
            Indicates if we are currently sending change notifications.
            </summary>
            <returns>If change notifications are being sent.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.SuppressChangeNotifications">
            <summary>
            Suppress change notifications until the return value is disposed.
            </summary>
            <returns>A IDisposable which when disposed will re-enable change notifications.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.AreChangeNotificationsDelayed">
            <summary>
            Are change notifications currently delayed. Used for Observables change notifications only.
            </summary>
            <returns>If the change notifications are delayed.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.IExtensionState`1.DelayChangeNotifications">
            <summary>
            Delay change notifications until the return value is disposed.
            </summary>
            <returns>A IDisposable which when disposed will re-enable change notifications.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaiseAndSetIfChanged``2(``0,``1@,``1,System.String)">
            <summary>
            RaiseAndSetIfChanged fully implements a Setter for a read-write
            property on a ReactiveObject, using CallerMemberName to raise the notification
            and the ref to the backing field to set the property.
            </summary>
            <typeparam name="TObj">The type of the This.</typeparam>
            <typeparam name="TRet">The type of the return value.</typeparam>
            <param name="this">The <see cref="T:ReactiveUI.ReactiveObject"/> raising the notification.</param>
            <param name="backingField">A Reference to the backing field for this
            property.</param>
            <param name="newValue">The new value.</param>
            <param name="propertyName">The name of the property, usually
            automatically provided through the CallerMemberName attribute.</param>
            <returns>The newly set value, normally discarded.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaisePropertyChanged``1(``0,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <param name="this">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaisePropertyChanging``1(``0,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <typeparam name="TSender">The sender type.</typeparam>
            <param name="this">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.Dedup``1(System.Collections.Generic.IList{ReactiveUI.IReactivePropertyChangedEventArgs{``0}})">
            <summary>
            Filter a list of change notifications, returning the last change for each PropertyName in original order.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1"/> class.
            </summary>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            If this method is called multiple times it will reference count
            and not perform notification until all values returned are disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1.DelayChangeNotifications">
            <summary>
            When this method is called, an object will not dispatch change
            Observable notifications until the return value is disposed.
            When the Disposable it will dispatched all queued notifications.
            If this method is called multiple times it will reference count
            and not perform notification until all values returned are disposed.
            </summary>
            <returns>An object that, when disposed, re-enables Observable change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.ReactiveObject">
            <summary>
            ReactiveObject is the base object for ViewModel classes, and it
            implements INotifyPropertyChanged. In addition, ReactiveObject provides
            Changing and Changed Observables to monitor object changes.
            </summary>
        </member>
        <member name="E:ReactiveUI.ReactiveObject.PropertyChanging">
            <inheritdoc/>
        </member>
        <member name="E:ReactiveUI.ReactiveObject.PropertyChanged">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changing">
            <inheritdoc />
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changed">
            <inheritdoc />
        </member>
        <member name="P:ReactiveUI.ReactiveObject.ThrownExceptions">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.ReactiveUI#IReactiveObject#RaisePropertyChanging(ReactiveUI.PropertyChangingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.ReactiveUI#IReactiveObject#RaisePropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.SuppressChangeNotifications">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.AreChangeNotificationsEnabled">
            <summary>
            Determines if change notifications are enabled or not.
            </summary>
            <returns>A value indicating whether change notifications are enabled.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.DelayChangeNotifications">
            <summary>
            Delays notifications until the return IDisposable is disposed.
            </summary>
            <returns>A disposable which when disposed will send delayed notifications.</returns>
        </member>
        <member name="T:ReactiveUI.Registrations">
            <summary>
            The main registration for common classes for the Splat dependency injection.
            We have code that runs reflection through the different ReactiveUI classes
            searching for IWantsToRegiterStuff and will register all our required DI
            interfaces. The registered items in this classes are common for all Platforms.
            To get these registrations after the main ReactiveUI Initialization use the
            DependencyResolverMixins.InitializeReactiveUI() extension method.
            </summary>
        </member>
        <member name="M:ReactiveUI.Registrations.Register(System.Action{System.Func{System.Object},System.Type})">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.MessageBus">
             <summary>
             MessageBus represents an object that can act as a "Message Bus", a
             simple way for ViewModels and other objects to communicate with each
             other in a loosely coupled way.
            
             Specifying which messages go where is done via a combination of the Type
             of the message as well as an additional "Contract" parameter; this is a
             unique string used to distinguish between messages of the same Type, and
             is arbitrarily set by the client.
             </summary>
        </member>
        <member name="P:ReactiveUI.MessageBus.Current">
            <summary>
            Gets or sets the Current MessageBus.
            </summary>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified runtime and contract, this will overrwrite the existing registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract. CurrentThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The Type of the message to listen to.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>a Disposable.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="T:ReactiveUI.RoutableViewModelMixin">
            <summary>
            Extension methods associated with the IRoutableViewModel interface.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatedTo(ReactiveUI.IRoutableViewModel,System.Func{System.IDisposable})">
            <summary>
            This method allows you to set up connections that only operate
            while the ViewModel has focus, and cleans up when the ViewModel
            loses focus.
            </summary>
            <param name="this">The ViewModel to watch for focus changes.</param>
            <param name="onNavigatedTo">Called when the ViewModel is navigated
            to - return an IDisposable that cleans up all of the things that are
            configured in the method.</param>
            <returns>An IDisposable that lets you disconnect the entire process
            earlier than normal.</returns>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatedToObservable(ReactiveUI.IRoutableViewModel)">
             <summary>
             This method will return an observable that fires events every time
             the topmost ViewModel in the navigation stack is this ViewModel.
             This allows you to set up connections that only operate while the
             ViewModel has focus.
            
             The observable will complete when the ViewModel is removed completely
             from the navigation stack. If your ViewModel can be _removed_ from
             the navigation stack and then reused later, you must call this method
             and resubscribe each time it is reused.
             </summary>
             <param name="this">The viewmodel to watch for navigation changes.</param>
             <returns>An IObservable{Unit} that signals when the ViewModel has
             been added or brought to the top of the navigation stack. The
             observable completes when the ViewModel is no longer a part of the
             navigation stack.</returns>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatingFromObservable(ReactiveUI.IRoutableViewModel)">
             <summary>
             This method will return an observable that fires events _just before_
             the ViewModel is no longer the topmost ViewModel in the navigation
             stack. This allows you to clean up anything before losing focus.
            
             The observable will complete when the ViewModel is removed completely
             from the navigation stack. If your ViewModel can be _removed_ from
             the navigation stack and then reused later, you must call this method
             and resubscribe each time it is reused.
             </summary>
             /// <param name="this">The viewmodel to watch for navigation changes.</param>
             <returns>An IObservable{Unit} that signals when the ViewModel is no
             longer the topmost ViewModel in the navigation stack. The observable
             completes when the ViewModel is no longer a part of the navigation
             stack.</returns>
        </member>
        <member name="T:ReactiveUI.RoutingState">
            <summary>
            RoutingState manages the ViewModel Stack and allows ViewModels to
            navigate to other ViewModels.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingState.#cctor">
            <summary>
            Initializes static members of the <see cref="T:ReactiveUI.RoutingState"/> class.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingState.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.RoutingState"/> class.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingState.#ctor(System.Reactive.Concurrency.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.RoutingState"/> class.
            </summary>
            <param name="scheduler">A scheduler for where to send navigation changes to.</param>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigationStack">
            <summary>
            Gets the current navigation stack, the last element in the
            collection being the currently visible ViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.Scheduler">
            <summary>
            Gets or sets the scheduler used for commands. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateBack">
            <summary>
            Gets or sets a command which will navigate back to the previous element in the stack.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.Navigate">
            <summary>
            Gets or sets a comamnd that navigates to the a new element in the stack - the Execute parameter
            must be a ViewModel that implements IRoutableViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateAndReset">
            <summary>
            Gets or sets a command that navigates to a new element and resets the navigation stack (i.e. the
            new ViewModel will now be the only element in the stack) - the
            Execute parameter must be a ViewModel that implements
            IRoutableViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.CurrentViewModel">
            <summary>
            Gets or sets the current view model which is to be shown for the Routing.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigationChanged">
            <summary>
            Gets or sets an observable which will signal when the Navigation changes.
            </summary>
        </member>
        <member name="T:ReactiveUI.RoutingStateMixins">
            <summary>
            Extension methods associated with the RoutingState class.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.FindViewModelInStack``1(ReactiveUI.RoutingState)">
            <summary>
            Locate the first ViewModel in the stack that matches a certain Type.
            </summary>
            <typeparam name="T">The view model type.</typeparam>
            <param name="this">The routing state.</param>
            <returns>The matching ViewModel or null if none exists.</returns>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.GetCurrentViewModel(ReactiveUI.RoutingState)">
            <summary>
            Returns the currently visible ViewModel.
            </summary>
            <param name="this">The routing state.</param>
            <returns>The matching ViewModel or null if none exists.</returns>
        </member>
        <member name="T:ReactiveUI.RxApp">
            <summary>
            The main registration point for common class instances throughout a ReactiveUI application.
            </summary>
            <remarks>
            N.B. Why we have this evil global class
            In a WPF or UWP application, most commands must have the Dispatcher
            scheduler set, because notifications will end up being run on another thread;
            this happens most often in a CanExecute observable.Unfortunately, in a Unit
            Test framework, while the MS Test Unit runner will *set* the Dispatcher (so
            we can't even use the lack of its presence to determine whether we're in a
            test runner or not), none of the items queued to it will ever be executed
            during the unit test.
            Initially, I tried to plumb the ability to set the scheduler throughout the
            lasses, but when you start building applications on top of that, having to
            have *every single * class have a default Scheduler property is really
            irritating, with either default making life difficult.
            This class also initializes a whole bunch of other stuff, including the IoC container,
            logging and error handling.
            </remarks>
        </member>
        <member name="F:ReactiveUI.RxApp.SmallCacheLimit">
            <summary>
            The size of a small cache of items. Often used for the MemoizingMRUCache class.
            </summary>
        </member>
        <member name="F:ReactiveUI.RxApp.BigCacheLimit">
            <summary>
            The size of a large cache of items. Often used for the MemoizingMRUCache class.
            </summary>
        </member>
        <member name="M:ReactiveUI.RxApp.#cctor">
            <summary>
            Initializes static members of the <see cref="T:ReactiveUI.RxApp"/> class.
            </summary>
            <exception cref="T:ReactiveUI.UnhandledErrorException">Default exception when we have unhandled exception in RxUI.</exception>
        </member>
        <member name="P:ReactiveUI.RxApp.MainThreadScheduler">
            <summary>
            Gets or sets a scheduler used to schedule work items that
            should be run "on the UI thread". In normal mode, this will be
            DispatcherScheduler, and in Unit Test mode this will be Immediate,
            to simplify writing common unit tests.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.TaskpoolScheduler">
            <summary>
            Gets or sets the a the scheduler used to schedule work items to
            run in a background thread. In both modes, this will run on the TPL
            Task Pool.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.DefaultExceptionHandler">
            <summary>
            Gets or sets the Observer which signalled whenever an object that has a
            ThrownExceptions property doesn't Subscribe to that Observable. Use
            Observer.Create to set up what will happen - the default is to crash
            the application with an error message.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.SuspensionHost">
            <summary>
            Gets or sets the current SuspensionHost, a
            class which provides events for process lifetime events, especially
            on mobile devices.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.SupportsRangeNotifications">
            <summary>
            Gets or sets a value indicating whether your UI framework is brain-dead or not and will blow
            up if a INotifyCollectionChanged object returns a ranged Add.
            </summary>
        </member>
        <member name="T:ReactiveUI.ScheduledSubject`1">
            <summary>
            A subject which dispatches all its events on the specified Scheduler.
            </summary>
            <typeparam name="T">The type of item being dispatched by the Subject.</typeparam>
        </member>
        <member name="M:ReactiveUI.ScheduledSubject`1.#ctor(System.Reactive.Concurrency.IScheduler,System.IObserver{`0},System.Reactive.Subjects.ISubject{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ScheduledSubject`1"/> class.
            </summary>
            <param name="scheduler">The scheduler where to dispatch items to.</param>
            <param name="defaultObserver">A optional default observer where notifications will be sent.</param>
            <param name="defaultSubject">A optional default subject which this Subject will wrap.</param>
        </member>
        <member name="M:ReactiveUI.ScheduledSubject`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:ReactiveUI.ScheduledSubject`1.OnCompleted">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ScheduledSubject`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ScheduledSubject`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ScheduledSubject`1.Subscribe(System.IObserver{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ScheduledSubject`1.Dispose(System.Boolean)">
            <summary>
            Disposes of any managed resources in our class.
            </summary>
            <param name="isDisposing">If we are being called by the IDisposable method.</param>
        </member>
        <member name="T:ReactiveUI.WaitForDispatcherScheduler">
            <summary>
            This scheduler attempts to deal with some of the brain-dead defaults
            on certain Microsoft platforms that make it difficult to access the
            Dispatcher during startup. This class wraps a scheduler and if it
            isn't available yet, it simply runs the scheduled item immediately.
            </summary>
        </member>
        <member name="M:ReactiveUI.WaitForDispatcherScheduler.#ctor(System.Func{System.Reactive.Concurrency.IScheduler})">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.WaitForDispatcherScheduler"/> class.
            </summary>
            <param name="schedulerFactory">A func which will return a new scheduler.</param>
        </member>
        <member name="P:ReactiveUI.WaitForDispatcherScheduler.Now">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.WaitForDispatcherScheduler.Schedule``1(``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.WaitForDispatcherScheduler.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.WaitForDispatcherScheduler.Schedule``1(``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.DummySuspensionDriver">
            <summary>
            A suspension driver that does not do anything.
            Useful potentially for unit testing or for platforms
            where you don't want to use a Suspension Driver.
            </summary>
        </member>
        <member name="M:ReactiveUI.DummySuspensionDriver.LoadState">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.DummySuspensionDriver.SaveState(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.DummySuspensionDriver.InvalidateState">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.SuspensionHost">
            <summary>
            A internal state setup by other classes for the different suspension state of a application.
            The user does not implement themselves but is often setup via the AutoSuspendHelper class.
            </summary>
        </member>
        <member name="M:ReactiveUI.SuspensionHost.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.SuspensionHost"/> class.
            </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.IsResuming">
            <summary>
            Gets or sets a observable which notifies when the application is resuming.
            </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.IsUnpausing">
            <summary>
            Gets or sets a observable which notifies when the application is un-pausing.
            </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.ShouldPersistState">
            <summary>
            Gets or sets a observable which notifies when the application should persist its state.
            </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.IsLaunchingNew">
            <summary>
            Gets or sets a observable which notifies when a application is launching new.
            </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.ShouldInvalidateState">
            <summary>
            Gets or sets a observable which notifies when the application state should be invalidated.
            </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.CreateNewAppState">
            <summary>
            Gets or sets a Func which will generate a fresh application state.
            </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.AppState">
            <summary>
            Gets or sets the application state that will be used when suspending and resuming the class.
            </summary>
        </member>
        <member name="T:ReactiveUI.SuspensionHostExtensions">
            <summary>
            Extension methods associated with the ISuspensionHost interface.
            </summary>
        </member>
        <member name="M:ReactiveUI.SuspensionHostExtensions.ObserveAppState``1(ReactiveUI.ISuspensionHost)">
            <summary>
            Observe changes to the AppState of a class derived from ISuspensionHost.
            </summary>
            <typeparam name="T">The observable type.</typeparam>
            <param name="this">The suspension host.</param>
            <returns>An observable of the app state.</returns>
        </member>
        <member name="M:ReactiveUI.SuspensionHostExtensions.GetAppState``1(ReactiveUI.ISuspensionHost)">
            <summary>
            Get the current App State of a class derived from ISuspensionHost.
            </summary>
            <typeparam name="T">The app state type.</typeparam>
            <param name="this">The suspenstion host.</param>
            <returns>The app state.</returns>
        </member>
        <member name="M:ReactiveUI.SuspensionHostExtensions.SetupDefaultSuspendResume(ReactiveUI.ISuspensionHost,ReactiveUI.ISuspensionDriver)">
            <summary>
            Setup our suspension driver for a class derived off ISuspensionHost interface.
            This will make your suspension host respond to suspend and resume requests.
            </summary>
            <param name="this">The suspension host.</param>
            <param name="driver">The suspension driver.</param>
            <returns>A disposable which will stop responding to Suspend and Resume requests.</returns>
        </member>
        <member name="T:ReactiveUI.UnhandledErrorException">
            <summary>
            Indicates that an object implementing <see cref="T:ReactiveUI.IHandleObservableErrors"/> has caused an error and nothing is attached
            to <see cref="P:ReactiveUI.IHandleObservableErrors.ThrownExceptions"/> to handle that error.
            </summary>
        </member>
        <member name="M:ReactiveUI.UnhandledErrorException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledErrorException"/> class.
            </summary>
        </member>
        <member name="M:ReactiveUI.UnhandledErrorException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledErrorException"/> class.
            </summary>
            <param name="message">
            The exception message.
            </param>
        </member>
        <member name="M:ReactiveUI.UnhandledErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledErrorException"/> class.
            </summary>
            <param name="message">
            The exception message.
            </param>
            <param name="innerException">
            The exception that caused this exception.
            </param>
        </member>
        <member name="M:ReactiveUI.UnhandledErrorException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.UnhandledErrorException"/> class.
            </summary>
            <param name="info">The serialization information.</param>
            <param name="context">The serialization context.</param>
        </member>
        <member name="T:ReactiveUI.WhenAnyMixin">
            <summary>Extension methods associated with the WhenAny/WhenAnyValue classes.</summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of a
            property on an object has changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``2,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{ReactiveUI.IObservedChange{``0,``2},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``2,``3,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{``2,``3,``4,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{``2,``3,``4,``5,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Func{``2,``3,``4,``5,``6,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Func{``2,``3,``4,``5,``6,``7,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``9(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Func{``2,``3,``4,``5,``6,``7,``8,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``9(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``10(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``10(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``11(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``11(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``12(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``12(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``13(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``13(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``14(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Linq.Expressions.Expression{System.Func{``0,``13}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``14(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Linq.Expressions.Expression{System.Func{``0,``13}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},ReactiveUI.IObservedChange{``0,``13},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.DefaultViewLocator.#ctor(System.Func{System.String,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.DefaultViewLocator"/> class.
            </summary>
            <param name="viewModelToViewFunc">The method which will convert a ViewModel name into a View.</param>
        </member>
        <member name="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc">
            <summary>
            Gets or sets a function that is used to convert a view model name to a proposed view name.
            </summary>
            <remarks>
            <para>
            If unset, the default behavior is to change "ViewModel" to "View". If a different convention is followed, assign an appropriate function to this
            property.
            </para>
            <para>
            Note that the name returned by the function is a starting point for view resolution. Variants on the name will be resolved according to the rules
            set out by the <see cref="M:ReactiveUI.DefaultViewLocator.ResolveView``1(``0,System.String)"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:ReactiveUI.DefaultViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Returns the view associated with a view model, deriving the name of the type via <see cref="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc"/>, then discovering it via the
            service locator.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <remarks>
            <para>
            Given view model type <c>T</c> with runtime type <c>RT</c>, this implementation will attempt to resolve the following views:
            <list type="number">
            <item>
            <description>
            Look for a service registered under the type whose name is given to us by passing <c>RT</c> to <see cref="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc"/> (which defaults to changing "ViewModel" to "View").
            </description>
            </item>
            <item>
            <description>
            Look for a service registered under the type <c>IViewFor&lt;RT&gt;</c>.
            </description>
            </item>
            <item>
            <description>
            Look for a service registered under the type whose name is given to us by passing <c>T</c> to <see cref="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc"/> (which defaults to changing "ViewModel" to "View").
            </description>
            </item>
            <item>
            <description>
            Look for a service registered under the type <c>IViewFor&lt;T&gt;</c>.
            </description>
            </item>
            <item>
            <description>
            If <c>T</c> is an interface, change its name to that of a class (i.e. drop the leading "I"). If it's a class, change to an interface (i.e. add a leading "I").
            </description>
            </item>
            <item>
            <description>
            Repeat steps 1-4 with the type resolved from the modified name.
            </description>
            </item>
            </list>
            </para>
            </remarks>
            <param name="viewModel">
            The view model whose associated view is to be resolved.
            </param>
            <param name="contract">
            Optional contract to be used when resolving from Splat.
            </param>
            <returns>
            The view associated with the given view model.
            </returns>
        </member>
        <member name="T:ReactiveUI.SingleInstanceViewAttribute">
            <summary>
            Indicates that this View should be constructed _once_ and then used
            every time its ViewModel View is resolved.
            Obviously, this is not supported on Views that may be reused multiple
            times in the Visual Tree.
            </summary>
        </member>
        <member name="T:ReactiveUI.ViewContractAttribute">
            <summary>
            Allows an additional string to make view resolution more specific than
            just a type. When applied to your <see cref="T:ReactiveUI.IViewFor`1"/> -derived
            View, you can select between different Views for a single ViewModel
            instance.
            </summary>
        </member>
        <member name="M:ReactiveUI.ViewContractAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ViewContractAttribute"/> class.
            Constructs the ViewContractAttribute with a specific contract value.
            </summary>
            <param name="contract">The value of the contract for view
            resolution.</param>
        </member>
        <member name="P:ReactiveUI.ViewContractAttribute.Contract">
            <summary>
            Gets the contract to use when resolving the view in the Splat Dependency Injection engine.
            </summary>
        </member>
        <member name="T:ReactiveUI.ViewLocator">
            <summary>
            Helper class which will get the currently registered IViewLocator interface inside
            the Splat dependency injection container.
            </summary>
        </member>
        <member name="P:ReactiveUI.ViewLocator.Current">
            <summary>
            Gets the currently registered IViewLocator interface.
            </summary>
            <exception cref="T:System.Exception">
            If there is no IViewLocator registered.
            Can happen due to using your own DI container and don't rerun the
            DependencyResolverMixins.InitializeReactiveUI() method.
            Also can happen if you don't include all the NuGet packages.
            </exception>
        </member>
        <member name="T:ReactiveUI.ViewLocatorNotFoundException">
            <summary>
            An exception that is thrown if we are unable to find the View Locator.
            </summary>
        </member>
        <member name="M:ReactiveUI.ViewLocatorNotFoundException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ViewLocatorNotFoundException"/> class.
            </summary>
        </member>
        <member name="M:ReactiveUI.ViewLocatorNotFoundException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ViewLocatorNotFoundException"/> class.
            </summary>
            <param name="message">A user friendly message.</param>
        </member>
        <member name="M:ReactiveUI.ViewLocatorNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ViewLocatorNotFoundException"/> class.
            </summary>
            <param name="message">A user friendly message.</param>
            <param name="innerException">Any exception this exception is wrapping.</param>
        </member>
        <member name="M:ReactiveUI.ViewLocatorNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ViewLocatorNotFoundException"/> class.
            </summary>
            <param name="info">The serialization info.</param>
            <param name="context">The serialization context.</param>
        </member>
        <member name="T:ReactiveUI.ComponentModelTypeConverter">
            <summary>
            Binding Type Converter for component model.
            </summary>
        </member>
        <member name="M:ReactiveUI.ComponentModelTypeConverter.GetAffinityForObjects(System.Type,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ComponentModelTypeConverter.TryConvert(System.Object,System.Type,System.Object,System.Object@)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.PlatformRegistrations">
            <summary>
            .NET Framework platform registrations.
            </summary>
            <seealso cref="T:ReactiveUI.IWantsToRegisterStuff" />
        </member>
        <member name="M:ReactiveUI.PlatformRegistrations.Register(System.Action{System.Func{System.Object},System.Type})">
            <inheritdoc/>
        </member>
        <member name="T:System.Reactive.Disposables.DisposableMixins">
            <summary>
            Extension methods associated with the IDisposable interface.
            </summary>
        </member>
        <member name="M:System.Reactive.Disposables.DisposableMixins.DisposeWith``1(``0,System.Reactive.Disposables.CompositeDisposable)">
            <summary>
            Ensures the provided disposable is disposed with the specified <see cref="T:System.Reactive.Disposables.CompositeDisposable"/>.
            </summary>
            <typeparam name="T">
            The type of the disposable.
            </typeparam>
            <param name="this">
            The disposable we are going to want to be disposed by the CompositeDisposable.
            </param>
            <param name="compositeDisposable">
            The <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> to which <paramref name="this"/> will be added.
            </param>
            <returns>
            The disposable.
            </returns>
        </member>
        <member name="T:System.Reactive.Linq.Observable`1">
            <summary>
            Provides commonly required, statically-allocated, pre-canned observables.
            </summary>
            <typeparam name="T">
            The observable type.
            </typeparam>
        </member>
        <member name="F:System.Reactive.Linq.Observable`1.Empty">
            <summary>
            An empty observable of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observable`1.Never">
            <summary>
            An observable of type <typeparamref name="T"/> that never ticks a value.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observable`1.Default">
            <summary>
            An observable of type <typeparamref name="T"/> that ticks a single, default value.
            </summary>
        </member>
        <member name="T:System.Reactive.Linq.Observables">
            <summary>
            Provides commonly required, statically-allocated, pre-canned observables.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observables.True">
            <summary>
            An observable that ticks a single, Boolean value of <c>true</c>.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observables.False">
            <summary>
            An observable that ticks a single, Boolean value of <c>false</c>.
            </summary>
            <remarks>
            <para>
            This observable is equivalent to <c>Observable&lt;bool&gt;.Default</c>, but is provided for convenience.
            </para>
            </remarks>
        </member>
        <member name="F:System.Reactive.Linq.Observables.Unit">
            <summary>
            An observable that ticks <c>Unit.Default</c> as a single value.</summary>
            <remarks>
            <para>
            This observable is equivalent to <c>Observable&lt;Unit&gt;.Default</c>, but is provided for convenience.
            </para>
            </remarks>
        </member>
    </members>
</doc>
